<?xml version="1.0" encoding="utf-8"?>
<Script type="xscript4.0"><![CDATA[/**
 * @fileOverview
 * Utility 함수 모음
 */


 /**
 * @class 입력값이 null에 해당하는 경우 모두를 한번에 체크한다.
 * @param sValue - 체크할 문자열( 예 : null 또는 undefined 또는 "" 또는 "abc" )
 * @return Boolean sValue이 undefined, null, NaN, "", Array.length = 0인 경우 true
 */   
function gfn_isNull(sValue)
{
    if (new String(sValue).valueOf() == "undefined") return true;
    if (sValue == null) return true;
    var v_ChkStr = new String(sValue);
    
    if (v_ChkStr == null) return true;
    if (v_ChkStr.toString().length == 0 ) return true;
    
    return false;
}

 /**
 * @class 입력값이 존재하는지를 판단하여
          존재하는 경우 입력값을 그대로 반환, 그렇지 않으면 두 번째 파라미터를 반환하는 함수
 * @param Val - 입력값
 * @param newVal - Null일 경우 대체할 값
 * @return Null을 대치한 값
 */  
function gfn_nvl(Val, newVal)
{
	if (gfn_isNull(Val)) 
	{
		if (!gfn_isNull(newVal)) 
		{
			return newVal;
		}
		else {
			return "";
		}
	}
	else {
		return Val;
	}
	return Val;
}

/**
 * @class undefined을 ""로 리턴한다.
 * @param oParam - object나 문자열
 * @return undefined이면 "" 아니면 입력값
 */
function gfn_transNullToEmpty(oParam) {
    var strParam = new String(oParam);
    if(strParam.valueOf() == "undefined") {
        return "";
    }
    
    return oParam;
}

/**
 * @class 조건식이 true일 경우 trueVal, false일경우 falseVal를 반환한다.
 * @param expr     - 조건식
 * @param trueVal  - true value
 * @param falseVal - false value
 * @return expr이 true일 경우 trueVal, false일경우 falseVal
 */
function iif(cond, rtnTrue, rtnFalse)
{
	if(cond) 
	{
		return rtnTrue;
	} 
	else {
		return rtnFalse;
	}
} 
// function iif(expr, trueVal, falseVal) {
//     return expr ? trueVal : falseVal;
// }

/**
 * @class 비교할값과 비교값들을 비교해서 해당하는 비교값의 반환값을 반환
 * @param arg1 - 비교할값
 * @param arg2 - 비교값1
 * @param arg3 - 반환값1
 *          (비교값, 반환값 쌍 반복)
 * @return 비교할값에 해당하는 반환값
 */
function decode() {
    var i, fn;
    fn = decode;
    for( i = 1; i < fn.arguments.length; i+=2 ) {
        if( fn.arguments[0] == fn.arguments[i] )
            return fn.arguments[i+1];
    }
    return fn.arguments[i-2];
}

/**
 * @class Type Definition 에 정의된 Prefix 의 Url 얻어오기
 * @param prefixId - prefix id
 * @return url
 */
function gfn_getPrefixUrl(prefixId) 
{
    var url = "";
    for (var i=0; i<application.services.length; i++) {
        var objServices = application.services[i];
        
        if (objServices["prefixid"] == prefixId) {
            url = objServices["url"];
            break;
        }
    }
    return url;
}

/**
 * @class 컴퓨터의 IP Address를 조회한다.(IP가 여러개 존재시 첫번째 IP를 리턴한다.)
 * @param 없음
 * @return IP Address
 */
function gfn_getIpAddr() 
{
    var extComm = new ExtCommon();
    var retVal;
    var arrIpAddr = extComm.getIPAddress();
		
    if ( gfn_isNull(arrIpAddr) ) {
		var temp = extComm.getIPAdapterInfoEx();
		retVal = temp[0][3];
    } else {
		if (arrIpAddr.length > 0) {
			retVal = arrIpAddr[0];
		}
	}
	
    return retVal.toString();
}

/**
 * @class 해당 IP Address의 MAC Address를 조회한다.(IP가 여러개 존재시 첫번째 IP를 리턴한다.)
 * @param IP Address
 * @return MAC Address
 */
function gfn_getMacAddr(strIpAddr) 
{
    var extComm = new ExtCommon();
    var retVal = "";
    
    if (strIpAddr == null){
        strIpAddr = gfn_getIpAddr();
    }
    
    var arrIpMacAddr = extComm.getMacAddress();
    var arrIpMac;
    
    for (var i=0; i<arrIpMacAddr.length; i++) {
        arrIpMac = arrIpMacAddr[i].split(":");
        if(i==0){
            retVal = arrIpMac;
        } else {
            retVal += ","+arrIpMac;
        }
    }
    
    return retVal.toString().toUpperCase();
}

/**
 * @class MSIE Browser의 version 체크
 * @param 없음
 * @return Integer - MSIE Browser의 version
 */
function gfn_getMSIEVerion() 
{
   var extComm = new ExtCommon();
    
    var strKey   = "HKEY_LOCAL_MACHINE";
    var strPath  = "SOFTWARE\\Microsoft\\Internet Explorer";    // key 이하의 경로
    var strName  = "Version";          // 읽어 올 name
    var strType  = "S";                // 읽을 값이 숫자형이면“I”, 문자형이면“S”를 이용한다.
    
    // 레지스트리에 값을 읽어오기
    // 성공시 strName의 value 값을 리턴하며, 에러시에 False(0)을 리턴한다.
    var strMSIEVersion = extComm.regGetValue(strKey, strPath, strName, strType);
    //trace("Microsoft Internet Explorer Version is '" + strMSIEVersion + "'");
    var intVersion = gfn_parseInt(strMSIEVersion.split(".")[0]);
    
    return intVersion;
}

 /**
 * @class 입력값이 URL Type인지 체크하는 함수
 * @param strValue - 경로
 * @return boolean
 */ 
function gfn_isURL(strValue)
{
	if (gfn_isNull(strValue)) 
	{
		return false;
	}
	else if (strValue.indexOf(".") == -1) 
	{
		return false;
	}
	else 
	{
		return true;
	}
}

 /**
 * @class 입력값이 e-mail Type인지 체크하는 함수
 * @param strValue - 값
 * @return boolean
 */  
function gfn_isEmail(strValue)
{
	if (gfn_isNull(strValue)) 
	{
		return false;
	}

	var nIndexOfAt = strValue.indexOf("@");
	var nIndexOfDot = strValue.indexOf(".");
	var nLength = strValue.length;

	// "@" 이 하나도 없거나 맨 끝에 위치한  경우
	if (nIndexOfAt <= 0 || nIndexOfAt == nLength) 
	{
		return false;
	}

	// "." 이 하나도 없거나 맨 끝에 위치한 경우
	if (nIndexOfDot <= 0 || nIndexOfDot == nLength) 
	{
		return false;
	}

	// "@"이 두개 이상 존재하는 경우
	if (strValue.indexOf("@", nIndexOfAt + 1) != -1) 
	{
		return false;
	}

	// ".@" 인 경우 또는 "@."인 경우
	if (strValue.substr(nIndexOfAt - 1, 1) == "." || strValue.substr(nIndexOfAt + 1, 1) == ".") 
	{
		return false;
	}

	// "@" 이후에 "."이 존재하지 않는 경우
	if (strValue.indexOf(".", (nIndexOfAt + 2)) == -1) 
	{
		return false;
	}

	// 공백문자가 존재하는 경우
	if (strValue.indexOf(" ") != -1) 
	{
		return false;
	}

	return true;
}

 /**
 * @class 입력값이 전화번호 format 인지 체크하는 함수
 * @param strValue - 값
 * @return boolean
 */   
function gfn_isPhone(strValue)
{
	// null 이거나 "-"이 존재하지 않는 경우
	if (gfn_isNull(strValue) || (!gfn_isNull(strValue) && strValue.indexOf("-") == -1)) 
	{
		return false;
	}
	else if (strValue.indexOf(".") >= 0) 
	{
		return false;
	}
	else 
	{
		// "-" 사이의 값이 숫자가 아닌 경우
		var arrNumbers = strValue.split("-");
		for (var i = 0; i < arrNumbers.length; i++) 
		{
			if (!TOBE.isNumeric(arrNumbers[i])) 
			{
				return false;
			}
		}
	}
	return true;
}

 /**
 * @class 문자열이 숫자형식에 맞는지 여부 체크
 * @param strValue - 체크할 문자열숫자 ( 예 : "-1234.56" ) (단, ","가 들어있으면 안 됨)
 * @return boolean
 */  
function gfn_isNum(sNum)
{
	var c;
	var point_cnt = 0;
	var ret = true;

	if (gfn_isNull(sNum)) 
	{
		return false;
	}

	for (var i = 0; i < sNum.length; i++) 
	{
		c = sNum.charAt(i);
		if (i == 0 && (c == "+" || c == "-")) 
		{
		}
		else if (c >= "0" && c <= "9") 
		{
		}
		else if (c == ".") 
		{
			point_cnt++;
			if (point_cnt > 1) 
			{
				ret = false;
				break;
			}
		}
		else 
		{
			ret = false;
			break;
		}
	}

	return ret;
}

/**
 * @class 숫자 정합성 체크
 * @param val - 입력문자열
 * @return Boolean
 */
function gfn_isDigit(val) {
    var lvNum;
    var lvFlag   = "No";
    var lvRetVal = false;
    var lvLength;
    var i;
    
    if (gfn_isNull(val) == true) {
        lvFlag      = "Yes";
        lvRetVal = false;
        return lvRetVal;
    }
    
    lvLength = val.length;
    
    if ((val.toString().split(".").length > 2) && lvFlag == "No") {
        lvFlag   = "Yes";
        lvRetVal = false;
    }
    
    if (lvFlag == "No") {
        for (i = 0; i < lvLength ; i++) {
            lvNum = val.substr(i,1);
            if (i == 0) {
                if(gfn_isNum(lvNum) || (lvNum == "-" && val.substr(1, 1) != ".")
                    || (lvNum == "+"  && val.substr(1, 1) != ".")){
                    lvRetVal = true;
                } else {
                    lvRetVal = false;
                    break;
                }
            } else {
                if(gfn_isNum(lvNum) || (lvNum == "." && val.substr(i+1, 1).length != 0)) {
                    lvRetVal = true;
                } else {
                    lvRetVal = false;
                    break;
                }
            }
        }
    }

    return lvRetVal;
}

 /**
 * @class 문자열이 알파벳(a~z, A~Z)만으로 구성되어 있는지 체크
 * @param sVal - 체크할 문자열 ( 예 : "aAzZ" )
 * @return boolean
 */  
function gfn_isAlpha(sVal)
{
	if (gfn_isNull(sVal)) 
	{
		return false;
	}

	if (sVal.search("[^A-Za-z]") >= 0) 
	{
		return false;
	}
	else 
	{
		return true;
	}
}

 /**
 * @class 문자열이 알파벳(a~z, A~Z), 숫자만으로 구성되어 있는지 체크
 * @param sVal - 체크할 문자열 ( 예 : "aAzZ09" )
 * @return boolean
 */  
function gfn_isAlNum(sVal)
{
	if (gfn_isNull(sVal)) 
	{
		return false;
	}

	if (sVal.search("[^A-Za-z0-9]") >= 0) 
	{
		return false;
	}
	else 
	{
		return true;
	}
}

/**
 * @class 특수문자가 있는지 Check한다.
 * @param strValue  - 대상문자열
 * @return Boolean 형의 특수문자존재 여부
 */
function gfn_isSpecialChar(strValue) {
    for (var i = 0; i < strValue.length; i++) {
        var strChar = strValue.charAt(i);
        var ch = strChar.charCodeAt();
        
        if ( (ch >= 33 && ch <= 47) || (ch >= 58 && ch <= 64) || (ch >= 91 && ch <= 96) || (ch >= 123 && ch <= 126) ) {
            return true;
        }
    }
    
    return false;
}

/**
 * @class 한글만으로 되어 있는지 Check한다.
 * @param strValue  - 대상문자열
 * @return Boolean형의 한글 여부
 */
function gfn_isKoreanChar(strValue) {
    var retVal = true;
    for (i = 0; i < strValue.length; i++) {
        if (!((strValue.charCodeAt(i) > 0x3130 && strValue.charCodeAt(i) < 0x318F) || (strValue.charCodeAt(i) >= 0xAC00 && strValue.charCodeAt(i) <= 0xD7A3))) {
            retVal = false;
        }
    }
    
    return retVal;
}

/**
 * @class 한글이 있는지 Check한다.
 * @param strValue  - 대상문자열
 * @return Boolean형의 한글 여부
 */
function gfn_exitKoreanChar(strValue) {
	strValue = strValue.toString();

    for (i = 0; i < strValue.length; i++) {
        if ((strValue.charCodeAt(i) > 0x3130 && strValue.charCodeAt(i) < 0x318F) || (strValue.charCodeAt(i) >= 0xAC00 && strValue.charCodeAt(i) <= 0xD7A3)) {
            return true;
        }
    }
    return false;
}

/**
 * @class 주민등록번호 정합성 여부를 확인한다.
 * @param sJuminNo - 입력문자열(주민번호 13자리)
 * @return Boolen 형식의 정합성 체크
 */
function gfn_isJuminNo(sJuminNo) {
	sJuminNo = sJuminNo.toString();
    var birthYear   = gfn_getJuminYear(sJuminNo);
        birthYear  += sJuminNo.substr(0, 2);
    var birthMonth  = sJuminNo.substr(2, 2) - 1;
    var birthDate   = sJuminNo.substr(4, 2);
    var birth       = new Date(birthYear, birthMonth, birthDate);
    
    if ( birth.getYear() % 100 != sJuminNo.substr(0, 2) ||
         birth.getMonth() != birthMonth ||
         birth.getDate() != birthDate) {
        return false;
    }
    
    // Check Sum 코드의 유효성 검사
    buf = new Array(13);
    for (i = 0; i < 6; i++) buf[i] = parseInt(sJuminNo.charAt(i));
    for (i = 6; i < 13; i++) buf[i] = parseInt(sJuminNo.charAt(i));
    
    multipliers = [2,3,4,5,6,7,8,9,2,3,4,5];
    for (i = 0, sum = 0; i < 12; i++) sum += (buf[i] *= multipliers[i]);
    
    if ((11 - (sum % 11)) % 10 != buf[12]) {
        return false;
    } else {
        return true;
    }
}

/**
 * @class 주민번호 뒷 첫번째 자리로 년대를 return 한다.
 * @param strRsrno - 입력문자열(주민번호 13자리)
 * @return String
 */
function gfn_getJuminYear(strRsrno) {
    if (strRsrno.toString().length != 13) {
        return "N";
    }
    
    var vGb = strRsrno.toString().substr(6,1);
    
    if (vGb == '1' || vGb == '2' || vGb == '5' || vGb == '6') {
        return '19';
    } else if (vGb == '3' || vGb == '4' || vGb == '7' || vGb == '8') {
        return '20';
    }
}

/**
 * @class 주민번호로 성별을 Return 한다.
 * @param strRsrno - 입력문자열(주민번호 13자리)
 * @return 남자 'M' 여자 'W' 기타 'X'
 */
function gfn_getGender(strRsrno) {
    if (!(gfn_isJuminNo(strRsrno)))
        return false;
    
    var vSexGb = strRsrno.substr(6,1);
    
    if (vSexGb == '1' || vSexGb == '3' || vSexGb == '5' || vSexGb == '7') {
        return "M";
    } else if (vSexGb == '2' || vSexGb == '4' || vSexGb == '6' || vSexGb == '8') {
        return "W";
    } else {
        return "X";
    }
}

/**
 * @class 생년월일 또는 주민번호로 법적연령-만나이를 구한다.
 * @param sValue - 생년 월일 또는 주민 번호
 * @param sDate  - 기준일자
 * @return 나이 또는 true/false
 */
function gfn_getAge(sValue, sDate) {
    var vYear;
    var vMonth;
    var vDay;
    
    if (gfn_trim(sValue).length == 13) {
        // 주민번호 정합성 체크
        if (!gfn_isJuminNo(sValue)) return false;
        
        var vBefor = gfn_getJuminYear(sValue);
        if (vBefor == "N") return false;
        
        sValue = vBefor + sValue;
        vYear  = parseInt(sValue.substr(0, 4), 10);
        vMonth = parseInt(sValue.substr(4, 2), 10);
        vDay   = parseInt(sValue.substr(6, 2), 10);
    } else if (gfn_trim(sValue).length == 8) {
        vYear  = parseInt(sValue.substr(0, 4), 10);
        vMonth = parseInt(sValue.substr(4, 2), 10);
        vDay   = parseInt(sValue.substr(6, 2), 10);
        
        if (!gfn_isDate(sValue)) return false;
    } else {
        return false;
    }
    
    var vCurrentSystemDate;
    
    if (gfn_isDate(sDate) == true) {
        vCurrentSystemDate = sDate;
    } else if (gfn_isNull(sDate) != "") {
        return false;
    }
    
    var vCurrentSystemYear  = parseInt(vCurrentSystemDate.substr(0, 4), 10);
    var vCurrentSystemMonth = parseInt(vCurrentSystemDate.substr(4, 2), 10);
    var vCurrentSystemDay   = parseInt(vCurrentSystemDate.substr(6, 2), 10);
    var vAge = vCurrentSystemYear - vYear;
    
    if (vMonth > vCurrentSystemMonth) {
        vAge = vAge - 1;
    
    } else if (vMonth == vCurrentSystemMonth) {
        if (vDay > vCurrentSystemDay) {
            vAge = vAge - 1;
        }
    }
    
    if (vAge < 0) {
        vAge = 0;
    }
    
    return vAge;
}

/**
 * @class 사업자등록번호 정합성 확인
 * @param sValue - 사업자등록번호
 * @return Boolean 형식의 정합성 체크
 */
function gfn_isCompRegNo(sValue) {
    if( gfn_isNull(sValue) )    return false;
    
    var vCompNo = sValue.replace("-", "");
    var checkID = new Array(1, 3, 7, 1, 3, 7, 1, 3, 5, 1);
    var i, Sum=0, c2, remander;
    
    if (vCompNo.length != 10)
        return false;
    
    for (i = 0; i <= 7; i++)
        Sum += checkID[i] * vCompNo.charAt(i);
    
    c2 = "0" + (checkID[8] * vCompNo.charAt(8));
    c2 = c2.substring(c2.length - 2, c2.length);
    
    Sum += Math.floor(c2.charAt(0)) + Math.floor(c2.charAt(1));
    
    remander = (10 - (Sum % 10)) % 10;
    
    if (Math.floor(vCompNo.charAt(9)) != remander)
        return false;
    return true;
}

/**
 * @class 법인등록번호 정합성 확인
 * @param sValue - 법인등록번호
 * @return Boolean 형식의 정합성 체크
 */
function gfn_isCorpRegNo(sValue) {
    if( gfn_isNull(sValue) )    return false;
    
    var vCorpNo = sValue.replace("-", "");
    var checkID = new Array(1,2,1,2,1,2,1,2,1,2,1,2);
    var i, Sum=0, c2, remander;
    
    if (vCorpNo.length != 13)
        return false;
    
    for (i = 0; i <= 12; i++)
        Sum += checkID[i] * vCorpNo.charAt(i);
    
    remander = Sum / 10;
    var nIndex = remander.toString().indexOf(".");
    remander = remander.toString().substring(nIndex + 1, nIndex + 2);
    remander = 10 - remander;
    
    if (remander > 9 )
        remander = 0;
    if (remander == sValue.substring(12, 13))
        return true;
    
    return false
}

/**
 * @class 외국인 등록번호 여부를 확인한다.
 * @param strNo - 입력문자열(등록번호13자리)
 * @return Boolean 형식의 정합성 체크
 */
function gfn_isForeignerNo(strNo) {
    if (strNo.length != 13 || !isNumeric(strNo)) return false;
    
    var month = toNumber(strNo.substr(2, 2));
    var day   = toNumber(strNo.substr(4, 2));
    
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;
    
    var sum = 0;
    var odd = 0;
    var buf = array(13);
    var multipliers = [2,3,4,5,6,7,8,9,2,3,4,5];
    
    for (var i=0; i<13; i++) {
        buf[i] = toNumber(strNo.charAt(i));
    }
    
    if (buf[11] < 6) return false;
    
    odd = buf[7] * 10 + buf[8];
    if((odd%2) != 0) return false;
    
    for (var i=0; i<12; i++) {
        sum += (buf[i] * multipliers[i]);
    }
    
    sum = 11 - (sum % 11);
    
    if (sum >= 10) sum -= 10;
    sum += 2;
    if (sum >= 10) sum -= 10;
    
    if (buf[12] == sum) {
        return true;
    } else {
        return false;
    }
}

/**
 * @class 카드번호 여부를 확인한다.
 * @param strNo - 입력문자열(카드번호13자리)
 * @return Boolean 형식의 정합성 체크
 */
function gfn_isCardNo(strNo) {
    if (strNo.length < 13 || strNo.length > 19 || !isNumeric(strNo)) return false;
    
    var sum = 0;
    var buf = new Array();
    
    for (var i=0; i<strNo.length; i++) {
        buf[i] = toNumber(strNo.charAt(i));
    }
    
    var temp;
    for (var i=buf.length-1, j=0; i>=0; i--, j++) {
        temp = buf[i] * ((j%2) + 1);
        if (temp >= 10) {
            temp = temp - 9;
        }
        sum += temp;
    }
    
    if ((sum % 10) == 0) {
        return true;
    } else {
        return false;
    }
}

/**
 * @class 숫자 -> 한글로 변환
 * @param argPrice - 변환 할 값
 * @return 변환된 값 리턴 / 123 -> 일백이십삼
 */
function gfn_changeInt2Han(argPrice) {
    hn = new Array("영","일","이","삼","사","오","육","칠","팔","구");
    hj = new Array("","만","억","조","경","해");
    ul = new Array("영천","영백","영십","영");
    tm = new Array();
    result = "";
    
    if (argPrice.charAt(0)=="-") {
        result = "마이너스 ";
        argPrice = argPrice.substr(1,argPrice.length-1);
    }
    
    loop_size = Math.ceil(argPrice.length/4);
    tmpPrice = "";
    
    for (count=argPrice.length; count >= 0; count--)
        tmpPrice += argPrice.substring(count,count-1);
    argPrice = tmpPrice;
    
    for (A=0;A<loop_size;A++) {
        sum = hj[A] + " ";
        tm[A] = argPrice.substr(A*4,4);
        
        tm2 = "";
        
        for (count=tm[A].length; count >= 0; count--)
            tm2 += tm[A].substring(count,count-1);
        
        tm[A] = tm2;
        part_jari = tm[A].length;
        
        for (D=0;D<10;D++) {
            for (B=0;B<10;B++) tm[A] = tm[A].replace(B,hn[B]);
        }
        
        if (part_jari == 4) tm[A] = tm[A].charAt(0)+"천"+tm[A].charAt(1)+"백"+tm[A].charAt(2)+"십"+tm[A].charAt(3);
        else if (part_jari == 3) tm[A] = tm[A].charAt(0)+"백"+tm[A].charAt(1)+"십"+tm[A].charAt(2);
        else if (part_jari == 2) tm[A] = tm[A].charAt(0)+"십"+tm[A].charAt(1);
        else tm[A] = tm[A].charAt(0);
        
        for (C=0;C<4;C++) {
            if (tm[A].match(ul[C])) {
            part_jari--; tm[A] = tm[A].replace(ul[C],"");
            }
        }
        
        if (part_jari != 0) tm[A] += sum;
    }
    
    for (loop_size;loop_size>-1;loop_size--)
        result += tm[loop_size];
    
    result = result.replace("undefined","");
    
    return result;
}

/**
 * @class 숫자 -> 한자로 변환
 * @param argPrice - 변환 할 값
 * @return 변환된 값 리턴 / 123 -> 壹百貳拾參
 */
function gfn_changeInt2HanJa(argPrice) {
    hn = new Array("영","壹","貳","參","四","五","六","七","八","九");
    hj = new Array("","萬","億","兆");
    ul = new Array("영千","영百","영拾","영");
    tm = new Array();
    result = "";
    
    if (argPrice.charAt(0)=="-") {
        result = "마이너스 ";
        argPrice = argPrice.substr(1,argPrice.length-1);
    }
    loop_size = Math.ceil(argPrice.length/4);
    tmpPrice = "";
    for (count=argPrice.length; count >= 0; count--)
        tmpPrice += argPrice.substring(count,count-1);
    
    argPrice = tmpPrice;
    
    for (A=0;A<loop_size;A++) {
        sum = hj[A] + " ";
        tm[A] = argPrice.substr(A*4,4);
        
        tm2 = "";
        
        for (count=tm[A].length; count >= 0; count--)
        tm2 += tm[A].substring(count,count-1);
        
        tm[A] = tm2;
        part_jari = tm[A].length;
        for (D=0;D<10;D++) {
            for (B=0;B<10;B++) tm[A] = tm[A].replace(B,hn[B]);
        }
        
        if (part_jari == 4) tm[A] = tm[A].charAt(0)+"千"+tm[A].charAt(1)+"百"+tm[A].charAt(2)+"拾"+tm[A].charAt(3);
        else if (part_jari == 3) tm[A] = tm[A].charAt(0)+"百"+tm[A].charAt(1)+"拾"+tm[A].charAt(2);
        else if (part_jari == 2) tm[A] = tm[A].charAt(0)+"拾"+tm[A].charAt(1);
        else tm[A] = tm[A].charAt(0);
        for (C=0;C<4;C++) {
            if (tm[A].match(ul[C])) {
                part_jari--; tm[A] = tm[A].replace(ul[C],"");
            }
        }
        if (part_jari != 0) tm[A] += sum;
    }
    
    for (loop_size;loop_size>-1;loop_size--) result += tm[loop_size];
    result = result.replace("undefined","");
    
    return result;
}

 /**
 * @class 인자로 넘어 문자열에 Mask 처리
 * @param sVal - 값 String 
 * @param sFormat - Format 
 * @param strMask - 치환 될 마스크 문자열
 * @return Mask 처리된 문자열
 */
function gfn_getStrToMaskstr(sVal, sFormat, strMask)
{
	var sValue = gfn_trim(sVal);
	
	if (gfn_isNull(sValue)) return sValue;		
	if (new String(strMask).valueOf() == "undefined" || strMask == null) strMask = "#";
	
	var nPos = 0;
	var nLength = 0;
	var strRetValue = "";	
	if (sFormat.length > sValue.length) nLength = sFormat.length;
	else nLength = sValue.length;
	nLength = nLength + (sFormat.replace(strMask, "")).length;
	
	for (var i=0; i < nLength; i++) {
		var strValue = gfn_trim(sValue.substr(nPos, 1));
		if (gfn_isNull(strValue)) continue;
		var strFormat = gfn_trim(sFormat.substr(i, 1));
		if (gfn_isNull(strFormat) ) strFormat = strMask;
		
		if (strFormat == strMask) {
			strRetValue += strValue;
			nPos += 1;
		} 
		else {
			strRetValue += strFormat;
			
		}
	}

	return strRetValue;
}

var _arrFirst = [12593,12594,12596,12599,12600,12601,12609,12610,12611,12613,12614,12615,12616,12617,12618,12619,12620,12621,12622];
var _arrSecond = [12623,12624,12625,12626,12627,12628,12629,12630,12631,12632,12633,12634,12635,12636,12637,12638,12639,12640,12641,12642,12643];
var _arrThird = [0,12593,12594,12595,12596,12597,12598,12599,12601,12602,12603,12604,12605,12606,12607,12608,12609,12610,12612,12613,12614,12615,12616,12618,12619,12620,12621,12622];
/**
 * @class 한글 자소를 분리하여 리턴한다.
 * @param strInput - 변환 할 값
 * @return 변환된 값 리턴
 */
function gfn_getSpliceTextK(strInput) {
    var i;
    var strOut = "";
    for(i=0;i<strInput.length;i++) {
        var nCode = strInput.charCodeAt(i);
        if(nCode>=44032 && nCode <= 55203) {
            var nFirst = Math.floor((nCode - 44032) / 588);
            strOut += String.fromCharCode(_arrFirst[nFirst]);
            var nSecond = Math.floor(((nCode - 44032) % 588) / 28) ;
            strOut += String.fromCharCode(_arrSecond[nSecond]);
            var nThird = Math.floor((nCode - 44032) % 28) ;
            if(nThird > 0)
                strOut += String.fromCharCode(_arrThird[nThird]);
        } else {
            strOut += String.fromCharCode(nCode);
        }
    }
    return strOut;
}

var _arrFirstE = ["r","R","s","e","E","f","a","q","Q","t","T","d","w","W","c","z","x","v","g"];
var _arrSecondE = ["k","o","i","O","j","p","u","P","h","hk","ho","hl","y","n","nj","np","nl","b","m","ml","l"];
var _arrThirdE = ["","r","R","rt","s","sw","sg","e","f","fr","fa","fq","ft","fx","fv","fg","a","q","qt","t","T","d","w","c","z","x","v","g"];
var arrAllE = ["r","R","rt","s","sw","sg","e","E","f","fr","fa","fq","ft","fx","fv","fg","a","q","Q","qt","t","T","d","w","W","c","z","x","v","g","k","o","i","O","j","p","u","P","h","hk","ho","hl","y","n","nj","np","nl","b","m","ml","l"];
/**
 * @class 한글 자소를 분리하고 키보드에 매치되는 영문으로 리턴한다.
 * @param strInput - 변환 할 값
 * @return 변환된 값 리턴
 */
function gfn_getSpliceTextE(strInput) {
    var i;
    var strOutE = "";
    for(i=0;i<strInput.length;i++) {
        var nCode = strInput.charCodeAt(i);
        if(nCode>=44032 && nCode <= 55203) {
            var nFirst = Math.floor((nCode - 44032) / 588);
            strOutE += _arrFirstE[nFirst];
            var nSecond = Math.floor(((nCode - 44032) % 588) / 28) ;
            strOutE += _arrSecondE[nSecond];
            var nThird = Math.floor((nCode - 44032) % 28) ;
            if(nThird > 0)
                strOutE += _arrThirdE[nThird];
        } else if(nCode>=12593 && nCode <= 12643) {
            strOutE += arrAllE[nCode-12593];
        } else {
            strOutE += String.fromCharCode(nCode);
        }
    }
    return strOutE;
}

/**
 * @class JSON Object를 JSON String으로 변환하여 리턴한다.
 * @param object - JSON Object
 * @return JSON String
 */
function gfn_jsonObjectToString(object) {
    var isArray = (object.join && object.pop && object.push
                    && object.reverse && object.shift && object.slice && object.splice);
    var results = [];
    
    for (var i in object) {
        var value = object[i];
        
        if (typeof value == "object"){
            results.push((isArray ? "" : "\"" + i.toString() + "\" : ") + gfn_jsonObjectToString(value));
        }else if (value){
			value=gfn_addSlash(value);
            results.push((isArray ? "" : "\"" + i.toString() + "\" : ") + (typeof value == "string" ? "\"" + value + "\"" : value));
        }
    }
    
    return (isArray ? "[" : "{") + results.join(", ") + (isArray ? "]" : "}");
}

/**
 * @class JSON String을 JSON Object으로 변환하여 리턴한다.
 * @param strJson - JSON String
 * @return JSON Object
 */
function gfn_jsonStringToObject(strJson){
    return eval("(" + strJson + ")");
}


function gfn_addSlash(strValue){
	var str=strValue;
	if(typeof(str)=="string"){
		str=str.replace('\\','\\\\');
		str=str.replace('"','\\"');
		str=str.replace('\'','\\\'');
		str=str.replace('\n','\\n');
		str=str.replace('\r','\\r');
		//str=str.replace('\s','\\s');
		str=str.replace('\t','\\t');
	}
	return str;
}

/**
 * @class 해당 데이터를 암호화 처리
 * @param sSource - 암호화 처리할 대상 문자
 * @return String 암호화된 문자
 */
function gfn_encProc(sSource)
{
	if(!gfn_isNull(sSource)) {
		var ExtObj = new ExtCommon();
		var base64 = ExtObj.encodeBase64(sSource);
		
		return base64;
	}
	else
		return "";
}

/**
 * @class 해당 데이터를 복호화 처리
 * @param sSource - 암호화 처리할 대상 문자
 * @return String 복호화된 문자
 */
function gfn_decProc(sSource)
{
	if(!gfn_isNull(sSource)) {
		var ExtObj = new ExtCommon();
		var debase64 = ExtObj.decodeBase64(sSource, "OBJ");
		
		return debase64.getText(0);
	}
	else
		return "";
}

/**
 * @class 문자열에서 변환된 정수를 반환
 * @param sArg - 숫자형 문자
 * @return Integer 정수, 숫자형이 아니면 0
 */
function gfn_parseInt(sArg)
{
    return (isNaN(parseInt(sArg)) ? 0 : parseInt(sArg));
}

/**
 * @class 문자열에서 변환된 부동 소수점 숫자를 반환 
 * @param sArg - 숫자형 문자
 * @return Float 부동 소수점 숫자, 숫자형이 아니면 0
 */
function gfn_parseFloat(sArg)
{
    return (isNaN(parseFloat(sArg)) ? 0 : parseFloat(sArg));
}

/**
 * @class 숫자 인수보다 크거나 같은 가장 작은 정수 또는 고정 소수점 실수를 반환 
 * @param val - 숫자값
 * @param digit - 자리수
 * @return Float 정수 또는 부동 소수점 숫자
 */
function gfn_ceil(val, digit)
{
    if (gfn_isNull(digit))
        digit = 0;
        
    var nRetVal = Math.ceil(val, digit);

    return nRetVal;
}

/**
 * @class 숫자 인수보다 작거나 같은 가장 큰 정수 또는 고정 소수점 실수를 반환
 * @param val - 숫자값
 * @param digit - 자리수
 * @return Float 정수 또는 부동 소수점 숫자
 */
function gfn_floor(val, digit)
{
    if (gfn_isNull(digit))
        digit = 0;
        
    var nRetVal = Math.floor(val, digit);

    return nRetVal;
}

/**
 * @class 주어진 수식을 반올림하여 가장 가까운 정수 또는 고정 소수점 실수를 반환
 * @param val - 숫자값
 * @param digit - 자리수
 * @return Float 정수 또는 부동 소수점 숫자
 */
function gfn_round(val, digit)
{
    if (gfn_isNull(digit))
        digit = 0;
        
    var nRetVal = Math.round(val, digit);

    return nRetVal;
}

/**
 * @class String형태의 숫자값에 1000단위마타 콤마(,)를 삽입한다.
 * @param sNum - 숫자String
 * @param digit - 자리수
 * @return 1000단위 마다 콤마(,) 삽입한 String
 */
function gfn_numFormat(sNum, digit) 
{
	// 소숫점 반올림 처리
	if(!gfn_isNull(digit))
	{
		if ( (typeof sNum) == "string" ) {
			sNum = parseFloat(sNum);
		}
		sNum = gfn_round(sNum, digit);
	}
	
    if ( (typeof sNum) != "string" ) {
        sNum = sNum.toString();
    }

    sNum = gfn_trim(sNum);  //string
	var ppos, sDigit, nEnd, nStart=0, sRet="";
	
	if(gfn_isNull(sNum))
	    return "";
	
	if( sNum.charAt(0) == "+" || sNum.charAt(0) == "-" )
	{
		sRet += sNum.charAt(0);
		nStart = 1;
	}
		
	ppos = sNum.indexOf(".",nStart);
	if( ppos < 0 )
		nEnd = sNum.length;
	else
		nEnd = ppos;	
			
	// 양수 영역 , 처리
	sDigit = sNum.substr(nStart, nEnd-nStart);
	for( pos = 0 ; pos < sDigit.length ; pos ++ )
	{
		if( pos != 0 && (sDigit.length-pos)%3 == 0 )
			sRet += ",";
		sRet += sDigit.charAt(pos);
	}
	// 소숫점 자리수 더하기
	sRet += sNum.substr(nEnd);
	
	return sRet;
}

/**
 * @class 해당 객체의 value를 받아온다. disable 상태이면 ""을 리턴한다.
 * @param element (DOM 객체)
 * @return 객체의 vlue.
 */
function gfn_getValue(element){
	if(element == null){
		trace('경고 : gfn_getValue(element) 함수의 인자로 null을 사용해서는 안됩니다.');
		return "";
	}
	if (element.enable == true)
		return element.value
	return 	null;
}


/**
 * @class 해당 칼럼의 길이를 체크하여 뒤에서 부터 PassWord 처리한다.
 * @param sColumn Dataset의 Column명
 * @param nSize   PassWord처리할 자릿수
 * @return String Mask처리 형식
 */
function gfn_stringMask(sColumn, nSize)
{
	var nLength;
	var sMaskText = "";
	
	nLength = gfn_length(sColumn);
	if (nLength == 0) {
		sMaskText = "";
	}
	else {	
		sMaskText = gfn_rPad("", nLength-nSize, "#") + "{" + gfn_rPad("", nSize, "#") + "}";
	}

	return sMaskText;
}

 /**
 * @class 정수인 nStart ~ nEnd의 범위에 있는 숫자에 대하여 random값을 return한다.
 * @param nStart - 시작숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
 * @param nEnd - 끝숫자 ( 단, 정수, 만일 정수가 아니면 Math.floor(nStart)를 적용함)
 * @return Floor nStart ~ nEnd범위 중 random숫자 (단, nStart, nEnd도 포함됨)
 */ 
function gfn_getRandom(nStart, nEnd)
{
	var range_unit,rand,tmp;

	if (gfn_isNull(nStart) || gfn_isNull(nEnd)) 
	{
		return -1;
	}

	nStart = Math.floor(nStart);
	nEnd = Math.floor(nEnd);
	if (nStart > nEnd) 
	{
		tmp = nStart;
		nStart = nEnd;
		nEnd = tmp;
	}
	range_unit = nEnd - nStart + 1;

	var dt = new Date();
	rand = (dt.getMilliseconds() + (Math.random() * 2000)) / 3000;

	return Math.floor(rand * range_unit * 2) % range_unit + nStart;
}

 /**
 * @class Array에 있는 값들을 Distinct(중복제거)한다.
 * @param aOrg - 중복을 제거할 원래 Array ( 예 : (1,1,2,2,3,4,5) )
 * @return Array 중복이 제거된 Array ( 예 : (1,2,3,4,5) )
 */  
function gfn_setDistinct(aOrg)
{
	var i,j;
	var flag;
	var aDist = new Array();
	var vDist;

	if (gfn_isNull(aOrg)) 
	{
		return aDist;
	}

	for (i = 0; i < aOrg.length; i++) 
	{
		vDist = aOrg[i];
		flag = false;
		for (j = 0; j < aDist.length; j++) 
		{
			if ("x" + aDist[j] == "x" + vDist) 
			{
				flag = true;
				break;
			}
		}
		if (flag == false) 
		{
			aDist.getSetter(aDist.length).set(vDist);
		}
	}

	return aDist;
}

 /**
 * @class 1차원 배열에서 입력된 문자열이 있는 index를 반환
 * @param ArrObj - 1차원 배열
 * @param strKey - 검색할 문자열
 * @return Integer 찾은 배열 index
 */   
function gfn_findArray(ArrObj, strKey)
{
	for (var i = 0; i < ArrObj.length; i++) 
	{
		if (strKey == ArrObj[i]) 
		{
			return i;
		}
	}
	return -1;
}

 /**
 * @class 2차원 배열에서 입력된 문자열이 있는 index를 반환
 * @param Arr2Obj - 2차원 배열
 * @param strKey  - 검색할 문자열
 * @param index   - 검색할 차원
 * @return Integer 찾은 배열 index
 */ 
function gfn_findArray2(Arr2Obj, strKey, index)
{
	for (var i = 0; i < Arr2Obj.length; i++) 
	{
		if (strKey == Arr2Obj[i][index]) 
		{
			return i;
		}
	}
	return -1;
}

/****************************************************************************************
 * 입력 문자 검증 체크 시작
 ****************************************************************************************/

function gfn_characterChk(strInput, strLang, strAddChar) {
	
	var strComp = " ";		//Space 포함 적용
	var strChkChar;
	var rtnVal = "";
	
	strComp += strAddChar;
	
	if (gfn_isNull(strLang)) strLang = "KR";
	
	var arrLang = gfn_split(strLang, ",");

	for (i=0; i<arrLang.length; i++) {
		switch( (arrLang[i]) )		{
			case "KR": 	// Korean
				strComp += gfn_setCharKorean() + String.fromCharCode(13);
				break;
			case "EN":	// English
				strComp += gfn_setCharEnglish() + String.fromCharCode(13);
				break;
			case "JP": 	// Japaness
				strComp += gfn_setCharJapaness() + String.fromCharCode(13);
				break;
			case "CN":	// Chiness
				strComp += gfn_setCharChiness() + String.fromCharCode(13);
				break;
			case "NU": 	// Number
				strComp += gfn_SetChar_Number() + String.fromCharCode(13);
				break;
			case "SB":	// Symbol
				strComp += gfn_setCharSymbol() + String.fromCharCode(13);
				break;
		}
	}	
	
	// 오류 문자 비교 검색
	for (i=0; i<strInput.length; i++) {
		strChkChar = strInput.substr(i,1);		
		if (strComp.indexOf(strChkChar) == -1) {
			rtnVal += strChkChar + ",";
		}		
	}
	
	if (rtnVal.length > 0) {
		rtnVal = gfn_left(rtnVal, rtnVal.length - 1);
		return rtnVal;
	} else {
		return "";
	}
}

function gfn_setCharKorean() {

	var strFixChar;
	strFixChar += "가각간갇갈갉갊감갑값갓갔강갖갗같갚갛개객갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷"; 
	strFixChar += "걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧";
	strFixChar += "골곪곬곯곰곱곳공곶과곽관괄괆괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군";
	strFixChar += "굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기";
	strFixChar += "긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄";
	strFixChar += "껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈";
	strFixChar += "꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕";
	strFixChar += "끗끙끝끼끽낀낄낌낍낏낑";
	strFixChar += "나낙낚난낟날낡낢남납낫났낭낮낯낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘";
	strFixChar += "넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨";
	strFixChar += "뇌뇐뇔뇜뇝뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘";
	strFixChar += "늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢";
	strFixChar += "다닥닦단닫달닭닮닯닳담답닷닸당닺닻닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥덧덩";
	strFixChar += "덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨";
	strFixChar += "됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘";
	strFixChar += "딛딜딤딥딧딨딩딪따딱딴딸땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼";
	strFixChar += "떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸";
	strFixChar += "뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵";
	strFixChar += "라락란랄람랍랏랐랑랒랖랗래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐";
	strFixChar += "렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝";
	strFixChar += "룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩륫륭르륵른를름릅릇릉릊릍릎리";
	strFixChar += "릭린릴림립릿링";
	strFixChar += "마막만많맏말맑맒맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓";
	strFixChar += "메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼묀묄묍묏묑묘묜";
	strFixChar += "묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿";
	strFixChar += "밀밂밈밉밋밌밍및밑";
	strFixChar += "바박밖밗반받발밝밞밟밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗벙벚";
	strFixChar += "베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘";
	strFixChar += "뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅";
	strFixChar += "빈빌빎빔빕빗빙빚빛빠빡빤빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤";
	strFixChar += "뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥";
	strFixChar += "사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤샥샨샬샴샵샷샹섀섄섈섐섕서석섞섟";
	strFixChar += "선섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜";
	strFixChar += "솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭숯숱";
	strFixChar += "숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십";
	strFixChar += "싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠";
	strFixChar += "쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔";
	strFixChar += "씜씨씩씬씰씸씹씻씽";
	strFixChar += "아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩";
	strFixChar += "어억언얹얻얼얽얾엄업없엇었엉엊엌엎에엑엔엘엠엡엣엥여역엮연열엶엷염엽엾엿였영옅옆";
	strFixChar += "옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀";
	strFixChar += "욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨웩웬웰웸웹웽위윅윈";
	strFixChar += "윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응읒읓읔읕읖읗의읜읠읨읫이익인일읽읾";
	strFixChar += "잃임입잇있잉잊잎";
	strFixChar += "자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊점접젓";
	strFixChar += "정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄";
	strFixChar += "죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙";
	strFixChar += "즛증지직진짇질짊짐집짓징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍";
	strFixChar += "쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤";
	strFixChar += "쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧";
	strFixChar += "차착찬찮찰참찹찻찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄";
	strFixChar += "쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄";
	strFixChar += "췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층치칙친칟칠칡침칩칫칭";
	strFixChar += "카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠";
	strFixChar += "켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭";
	strFixChar += "퀴퀵퀸퀼큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹";
	strFixChar += "타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨";
	strFixChar += "텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜퉤튀튁튄튈튐튑튕튜";
	strFixChar += "튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅";
	strFixChar += "파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭";
	strFixChar += "펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩";
	strFixChar += "퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑";
	strFixChar += "하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현";
	strFixChar += "혈혐협혓혔형혜혠혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬";
	strFixChar += "횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖";
	strFixChar += "흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝";
	strFixChar += "\n";
	
	return strFixChar;
}

function gfn_setCharSymbol() {
	var strFixChar;
	strFixChar += "!@#$%^&*()-_+=\\{}[]~`:;\"\'<>,.?/";		
	return strFixChar;
}

function gfn_setCharEnglish() {
	var strFixAlphabat;
	strFixAlphabat += "abcdefghijklmnopqrstuvwxyz"; 
	strFixAlphabat += "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	return strFixAlphabat;
}

function gfn_setCharJapaness() {
	var strFixChar;	
	strFixChar += "ぁあぃいぅうぇえぉおかがきぎく";
	strFixChar += "ぐけげこごさざしじすずせぜそぞた";
	strFixChar += "だちぢっつづてでとどなにぬねのは";
	strFixChar += "ばぱひびぴふぶぷへべぺほぼぽまみ";
	strFixChar += "むめもゃやゅゆょよらりるれろゎわ";
	strFixChar += "ゐゑをん"	;	
	strFixChar += "ァアィイゥウェエォオカガキギク";
	strFixChar += "グケゲコゴサザシジスズセゼソゾタ";
	strFixChar += "ダチヂッツヅテデトドナニヌネノハ";
	strFixChar += "バパヒビピフブプヘベペホボポマミ";
	strFixChar += "ムメモャヤュユョヨラリルレロヮワ";
	strFixChar += "ヰヱヲンヴヵヶ";
	return strFixChar;
}

function gfn_setCharChiness() {
	var strFixChar;
	strFixChar += "伽佳假價加可呵哥嘉嫁家暇架枷柯";
	strFixChar += "歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却";
	strFixChar += "各恪慤殼珏脚覺角閣侃刊墾奸姦干幹";
	strFixChar += "懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫";
	strFixChar += "間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感";
	strFixChar += "憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕";
	strFixChar += "匣岬甲胛鉀閘剛堈姜岡崗康强彊慷";
	strFixChar += "江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介";
	strFixChar += "价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋";
	strFixChar += "豈鎧開喀客坑更粳羹醵倨去居巨拒据";
	strFixChar += "據擧渠炬祛距踞車遽鉅鋸乾件健巾建";
	strFixChar += "愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢";
	strFixChar += "瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡";
	strFixChar += "隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結";
	strFixChar += "缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿";
	strFixChar += "坰境庚徑慶憬擎敬景暻更梗涇炅烱璟";
	strFixChar += "璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕";
	strFixChar += "鏡頃頸驚鯨係啓堺契季屆悸戒桂械";
	strFixChar += "棨溪界癸磎稽系繫繼計誡谿階鷄古";
	strFixChar += "叩告呱固姑孤尻庫拷攷故敲暠枯槁沽";
	strFixChar += "痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈";
	strFixChar += "辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑";
	strFixChar += "昆梱棍滾琨袞鯤汨滑骨供公共功孔工";
	strFixChar += "恐恭拱控攻珙空蚣貢鞏串寡戈果瓜";
	strFixChar += "科菓誇課跨過鍋顆廓槨藿郭串冠官";
	strFixChar += "寬慣棺款灌琯瓘管罐菅觀貫關館刮恝";
	strFixChar += "括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦";
	strFixChar += "掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交";
	strFixChar += "僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠";
	strFixChar += "蕎蛟較轎郊餃驕鮫丘久九仇俱具勾";
	strFixChar += "區口句咎嘔坵垢寇嶇廐懼拘救枸柩";
	strFixChar += "構歐毆毬求溝灸狗玖球瞿矩究絿耉臼";
	strFixChar += "舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜";
	strFixChar += "國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟";
	strFixChar += "宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷";
	strFixChar += "厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴";
	strFixChar += "鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳";
	strFixChar += "逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極";
	strFixChar += "隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉";
	strFixChar += "契今妗擒昑檎琴禁禽芩衾衿襟金錦伋";
	strFixChar += "及急扱汲級給亘兢矜肯企伎其冀嗜器";
	strFixChar += "圻基埼夔奇妓寄岐崎己幾忌技旗旣";
	strFixChar += "朞期杞棋棄機欺氣汽沂淇玘琦琪璂";
	strFixChar += "璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌";
	strFixChar += "記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮";
	strFixChar += "桔金喫儺喇奈娜懦懶拏拿癩羅蘿螺裸";
	strFixChar += "邏那樂洛烙珞落諾酪駱亂卵暖欄煖爛";
	strFixChar += "蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉";
	strFixChar += "納臘蠟衲囊娘廊朗浪狼郎乃來內奈";
	strFixChar += "柰耐冷女年撚秊念恬拈捻寧寗努勞奴";
	strFixChar += "弩怒擄櫓爐瑙盧老蘆虜路露駑魯鷺碌";
	strFixChar += "祿綠菉錄鹿論壟弄濃籠聾膿農惱牢磊";
	strFixChar += "腦賂雷尿壘屢樓淚漏累縷陋嫩訥杻紐";
	strFixChar += "勒肋凜凌稜綾能菱陵尼泥匿溺多茶";
	strFixChar += "丹亶但單團壇彖斷旦檀段湍短端簞";
	strFixChar += "緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡";
	strFixChar += "湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝";
	strFixChar += "唐堂塘幢戇撞棠當糖螳黨代垈坮大對";
	strFixChar += "岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀";
	strFixChar += "到圖堵塗導屠島嶋度徒悼挑掉搗桃";
	strFixChar += "棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳";
	strFixChar += "蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤";
	strFixChar += "纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬";
	strFixChar += "凍動同憧東桐棟洞潼疼瞳童胴董銅兜";
	strFixChar += "斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍";
	strFixChar += "得嶝橙燈登等藤謄鄧騰喇懶拏癩羅";
	strFixChar += "蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂";
	strFixChar += "卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜";
	strFixChar += "藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍";
	strFixChar += "徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒";
	strFixChar += "輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭";
	strFixChar += "驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣";
	strFixChar += "煉璉練聯蓮輦連鍊冽列劣洌烈裂廉";
	strFixChar += "斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎";
	strFixChar += "聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄";
	strFixChar += "櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿";
	strFixChar += "綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢";
	strFixChar += "磊賂賚賴雷了僚寮廖料燎療瞭聊蓼";
	strFixChar += "遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤";
	strFixChar += "陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六";
	strFixChar += "戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜";
	strFixChar += "凌楞稜綾菱陵俚利厘吏唎履悧李梨浬";
	strFixChar += "犁狸理璃異痢籬罹羸莉裏裡里釐離鯉";
	strFixChar += "吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬";
	strFixChar += "立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜";
	strFixChar += "莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬";
	strFixChar += "蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙";
	strFixChar += "望網罔芒茫莽輞邙埋妹媒寐昧枚梅每";
	strFixChar += "煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟";
	strFixChar += "萌冪覓免冕勉棉沔眄眠綿緬面麵滅";
	strFixChar += "蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘";
	strFixChar += "鳴袂侮冒募姆帽慕摸摹暮某模母毛牟";
	strFixChar += "牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆";
	strFixChar += "鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗";
	strFixChar += "苗錨務巫憮懋戊拇撫无楙武毋無珷畝";
	strFixChar += "繆舞茂蕪誣貿霧鵡墨默們刎吻問文";
	strFixChar += "汶紊紋聞蚊門雯勿沕物味媚尾嵋彌";
	strFixChar += "微未梶楣渼湄眉米美薇謎迷靡黴岷悶";
	strFixChar += "愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博";
	strFixChar += "拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹";
	strFixChar += "駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤";
	strFixChar += "盼磐磻礬絆般蟠返頒飯勃拔撥渤潑";
	strFixChar += "發跋醱鉢髮魃倣傍坊妨尨幇彷房放";
	strFixChar += "方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗";
	strFixChar += "邦防龐倍俳北培徘拜排杯湃焙盃背胚";
	strFixChar += "裴裵褙賠輩配陪伯佰帛柏栢白百魄幡";
	strFixChar += "樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵";
	strFixChar += "氾汎泛犯範范法琺僻劈壁擘檗璧癖";
	strFixChar += "碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈";
	strFixChar += "丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠";
	strFixChar += "騈保堡報寶普步洑湺潽珤甫菩補褓譜";
	strFixChar += "輔伏僕匐卜宓復服福腹茯蔔複覆輹輻";
	strFixChar += "馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬";
	strFixChar += "蜂逢鋒鳳不付俯傅剖副否咐埠夫婦";
	strFixChar += "孚孵富府復扶敷斧浮溥父符簿缶腐";
	strFixChar += "腑膚艀芙莩訃負賦賻赴趺部釜阜附駙";
	strFixChar += "鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉";
	strFixChar += "糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬";
	strFixChar += "丕備匕匪卑妃婢庇悲憊扉批斐枇榧比";
	strFixChar += "毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥";
	strFixChar += "脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬";
	strFixChar += "斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍";
	strFixChar += "事些仕伺似使俟僿史司唆嗣四士奢娑";
	strFixChar += "寫寺射巳師徙思捨斜斯柶査梭死沙泗";
	strFixChar += "渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇";
	strFixChar += "裟詐詞謝賜赦辭邪飼駟麝削數朔索";
	strFixChar += "傘刪山散汕珊産疝算蒜酸霰乷撒殺";
	strFixChar += "煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷";
	strFixChar += "像償商喪嘗孀尙峠常床庠廂想桑橡湘";
	strFixChar += "爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽";
	strFixChar += "嗇塞穡索色牲生甥省笙墅壻嶼序庶徐";
	strFixChar += "恕抒捿敍暑曙書栖棲犀瑞筮絮緖署";
	strFixChar += "胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳";
	strFixChar += "析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇";
	strFixChar += "敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船";
	strFixChar += "蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌";
	strFixChar += "薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉";
	strFixChar += "燮葉城姓宬性惺成星晟猩珹盛省筬";
	strFixChar += "聖聲腥誠醒世勢歲洗稅笹細說貰召";
	strFixChar += "嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤";
	strFixChar += "燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡";
	strFixChar += "邵銷韶騷俗屬束涑粟續謖贖速孫巽損";
	strFixChar += "蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎";
	strFixChar += "鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁";
	strFixChar += "戍手授搜收數樹殊水洙漱燧狩獸琇";
	strFixChar += "璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪";
	strFixChar += "袖誰讐輸遂邃酬銖銹隋隧隨雖需須首";
	strFixChar += "髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇";
	strFixChar += "循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜";
	strFixChar += "荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧";
	strFixChar += "嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承";
	strFixChar += "昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施";
	strFixChar += "是時枾柴猜矢示翅蒔蓍視試詩諡豕豺";
	strFixChar += "埴寔式息拭植殖湜熄篒蝕識軾食飾伸";
	strFixChar += "侁信呻娠宸愼新晨燼申神紳腎臣莘薪";
	strFixChar += "藎蜃訊身辛辰迅失室實悉審尋心沁";
	strFixChar += "沈深瀋甚芯諶什十拾雙氏亞俄兒啞";
	strFixChar += "娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳";
	strFixChar += "嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏";
	strFixChar += "案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌";
	strFixChar += "菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃";
	strFixChar += "崖愛曖涯碍艾隘靄厄扼掖液縊腋額";
	strFixChar += "櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野";
	strFixChar += "弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙";
	strFixChar += "揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊";
	strFixChar += "良襄諒讓釀陽量養圄御於漁瘀禦語馭";
	strFixChar += "魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺";
	strFixChar += "儼嚴奄掩淹嶪業円予余勵呂女如廬";
	strFixChar += "旅歟汝濾璵礖礪與艅茹輿轝閭餘驪";
	strFixChar += "麗黎亦力域役易曆歷疫繹譯轢逆驛嚥";
	strFixChar += "堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓";
	strFixChar += "淵演漣烟然煙煉燃燕璉硏硯秊筵緣練";
	strFixChar += "縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈";
	strFixChar += "熱裂說閱厭廉念捻染殮炎焰琰艶苒";
	strFixChar += "簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影";
	strFixChar += "怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲";
	strFixChar += "瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈";
	strFixChar += "領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮";
	strFixChar += "裔詣譽豫醴銳隸霓預五伍俉傲午吾吳";
	strFixChar += "嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳";
	strFixChar += "烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥";
	strFixChar += "瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦";
	strFixChar += "窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗";
	strFixChar += "緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃";
	strFixChar += "歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥";
	strFixChar += "寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療";
	strFixChar += "窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾";
	strFixChar += "欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌";
	strFixChar += "湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶";
	strFixChar += "優又友右宇寓尤愚憂旴牛玗瑀盂祐禑";
	strFixChar += "禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭";
	strFixChar += "昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓";
	strFixChar += "運隕雲韻蔚鬱亐熊雄元原員圓園垣";
	strFixChar += "媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅";
	strFixChar += "遠阮院願鴛月越鉞位偉僞危圍委威尉";
	strFixChar += "慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋";
	strFixChar += "魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈";
	strFixChar += "愉揄攸有杻柔柚柳楡楢油洧流游溜";
	strFixChar += "濡猶猷琉瑜由留癒硫紐維臾萸裕誘";
	strFixChar += "諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉";
	strFixChar += "育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律";
	strFixChar += "慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱";
	strFixChar += "乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚";
	strFixChar += "儀宜意懿擬椅毅疑矣義艤薏蟻衣誼";
	strFixChar += "議醫二以伊利吏夷姨履已弛彛怡易";
	strFixChar += "李梨泥爾珥理異痍痢移罹而耳肄苡荑";
	strFixChar += "裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼";
	strFixChar += "謚人仁刃印吝咽因姻寅引忍湮燐璘絪";
	strFixChar += "茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸";
	strFixChar += "鎰馹任壬妊姙恁林淋稔臨荏賃入卄";
	strFixChar += "立笠粒仍剩孕芿仔刺咨姉姿子字孜";
	strFixChar += "恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮";
	strFixChar += "資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱";
	strFixChar += "棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻";
	strFixChar += "壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐";
	strFixChar += "璋章粧腸臟臧莊葬蔣薔藏裝贓醬長";
	strFixChar += "障再哉在宰才材栽梓渽滓災縡裁財";
	strFixChar += "載齋齎爭箏諍錚佇低儲咀姐底抵杵楮";
	strFixChar += "樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這";
	strFixChar += "邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍";
	strFixChar += "績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全";
	strFixChar += "典前剪塡塼奠專展廛悛戰栓殿氈澱";
	strFixChar += "煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿";
	strFixChar += "銓錢鐫電顚顫餞切截折浙癤竊節絶占";
	strFixChar += "岾店漸点粘霑鮎點接摺蝶丁井亭停偵";
	strFixChar += "呈姃定幀庭廷征情挺政整旌晶晸柾楨";
	strFixChar += "檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程";
	strFixChar += "穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖";
	strFixChar += "靜頂鼎制劑啼堤帝弟悌提梯濟祭第";
	strFixChar += "臍薺製諸蹄醍除際霽題齊俎兆凋助嘲";
	strFixChar += "弔彫措操早晁曺曹朝條棗槽漕潮照燥";
	strFixChar += "爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔";
	strFixChar += "調趙躁造遭釣阻雕鳥族簇足鏃存尊卒";
	strFixChar += "拙猝倧宗從悰慫棕淙琮種終綜縱腫";
	strFixChar += "踪踵鍾鐘佐坐左座挫罪主住侏做姝";
	strFixChar += "胄呪周嗾奏宙州廚晝朱柱株注洲湊澍";
	strFixChar += "炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎";
	strFixChar += "酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬";
	strFixChar += "焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫";
	strFixChar += "汁葺增憎曾拯烝甑症繒蒸證贈之只";
	strFixChar += "咫地址志持指摯支旨智枝枳止池沚";
	strFixChar += "漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾";
	strFixChar += "遲直稙稷織職唇嗔塵振搢晉晋桭榛殄";
	strFixChar += "津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗";
	strFixChar += "診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆";
	strFixChar += "疾秩窒膣蛭質跌迭斟朕什執潗緝輯";
	strFixChar += "鏶集徵懲澄且侘借叉嗟嵯差次此磋";
	strFixChar += "箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨";
	strFixChar += "瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮";
	strFixChar += "僭參塹慘慙懺斬站讒讖倉倡創唱娼廠";
	strFixChar += "彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼";
	strFixChar += "債埰寀寨彩採砦綵菜蔡采釵冊柵策";
	strFixChar += "責凄妻悽處倜刺剔尺慽戚拓擲斥滌";
	strFixChar += "瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛";
	strFixChar += "薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟";
	strFixChar += "轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷";
	strFixChar += "牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃";
	strFixChar += "替涕滯締諦逮遞體初剿哨憔抄招梢";
	strFixChar += "椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉";
	strFixChar += "貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢";
	strFixChar += "塚寵悤憁摠總聰蔥銃撮催崔最墜抽推";
	strFixChar += "椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘";
	strFixChar += "鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐";
	strFixChar += "春椿瑃出朮黜充忠沖蟲衝衷悴膵萃";
	strFixChar += "贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲";
	strFixChar += "側仄厠惻測層侈値嗤峙幟恥梔治淄熾";
	strFixChar += "痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅";
	strFixChar += "飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤";
	strFixChar += "稱快他咤唾墮妥惰打拖朶楕舵陀馱駝";
	strFixChar += "倬卓啄坼度托拓擢晫柝濁濯琢琸託";
	strFixChar += "鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈";
	strFixChar += "耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆";
	strFixChar += "汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土";
	strFixChar += "討慟桶洞痛筒統通堆槌腿褪退頹偸套";
	strFixChar += "妬投透鬪慝特闖坡婆巴把播擺杷波派";
	strFixChar += "爬琶破罷芭跛頗判坂板版瓣販辦鈑";
	strFixChar += "阪八叭捌佩唄悖敗沛浿牌狽稗覇貝";
	strFixChar += "彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶";
	strFixChar += "坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈";
	strFixChar += "包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲";
	strFixChar += "胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆";
	strFixChar += "輻俵剽彪慓杓標漂瓢票表豹飇飄驃";
	strFixChar += "品稟楓諷豊風馮彼披疲皮被避陂匹";
	strFixChar += "弼必泌珌畢疋筆苾馝乏逼下何厦夏廈";
	strFixChar += "昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨";
	strFixChar += "悍旱汗漢澣瀚罕翰閑閒限韓割轄函含";
	strFixChar += "咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔";
	strFixChar += "陜亢伉姮嫦巷恒抗杭桁沆港缸肛航";
	strFixChar += "行降項亥偕咳垓奚孩害懈楷海瀣蟹";
	strFixChar += "解該諧邂駭骸劾核倖幸杏荇行享向嚮";
	strFixChar += "珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險";
	strFixChar += "驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩";
	strFixChar += "睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠";
	strFixChar += "協夾峽挾浹狹脅脇莢鋏頰亨兄刑型";
	strFixChar += "形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣";
	strFixChar += "馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好";
	strFixChar += "岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐";
	strFixChar += "琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪";
	strFixChar += "鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄";
	strFixChar += "弘汞泓洪烘紅虹訌鴻化和嬅樺火畵";
	strFixChar += "禍禾花華話譁貨靴廓擴攫確碻穫丸";
	strFixChar += "喚奐宦幻患換歡晥桓渙煥環紈還驩鰥";
	strFixChar += "活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況";
	strFixChar += "湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻";
	strFixChar += "徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨";
	strFixChar += "賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆";
	strFixChar += "爻肴酵驍侯候厚后吼喉嗅帿後朽煦";
	strFixChar += "珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊";
	strFixChar += "萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦";
	strFixChar += "虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹";
	strFixChar += "紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬";
	strFixChar += "嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰";	
	return strFixChar;
}

/****************************************************************************************
 * 입력 문자 검증 체크 종료
 ****************************************************************************************/

 /**
 * Dataset의 컬럼정보를 얻는다.
 * @param objDs - Dataset Object
 * @return ColumnInfo 배열
 */ 
 function gfn_getDatasetInfo (objDs) {
	var objColInfo = new Array();

	//데이터셋 컬럼정보 설정 
	for (var i=0; i < objDs.getColCount(); i++) {
		objColInfo[i] = objDs.getColumnInfo(i);
	}
	
	return objColInfo;
}

 /**
 * Dataset의 컬럼정보로 초기화한다.
 * @param objDs - Dataset Object
 * @param objColInfo - ColumnInfo 배열
 * @return None
 */ 
function gfn_loadDatasetInfo (objDs, objColInfo) {
	var xmlText ;
	xmlText ="<Dataset id=\"" + objDs.id + "\">";
	xmlText =xmlText +"<ColumnInfo>";
	for (var i=0; i < objColInfo.length; i++) {
		xmlText =xmlText +"<Column id=\"" + objColInfo[i].name + "\" type=\""  + objColInfo[i].type + "\" size=\"" +  + objColInfo[i].size  + "\"/>";
	}
	xmlText =xmlText +"</ColumnInfo>";
	xmlText =xmlText +"</Dataset>";
	
	objDs.clear();
	objDs.loadXML(xmlText);
}

function gfn_queryString(url) {
  // This function is anonymous, is executed immediately and 
  // the return value is assigned to QueryString!
  var query_string = {};
  var query = url.substr(url.indexOf("?")+1, url.length);
  var vars = query.split("&");
  for (var i=0;i<vars.length;i++) {
    var pair = vars[i].split("=");
        // If first entry with this name
    if (typeof query_string[pair[0]] === "undefined") {
      query_string[pair[0]] = decodeURIComponent(pair[1]);
        // If second entry with this name
    } else if (typeof query_string[pair[0]] === "string") {
      var arr = [ query_string[pair[0]],decodeURIComponent(pair[1]) ];
      query_string[pair[0]] = arr;
        // If third or later entry with this name
    } else {
      query_string[pair[0]].push(decodeURIComponent(pair[1]));
    }
  } 
  return query_string;
}]]></Script>
