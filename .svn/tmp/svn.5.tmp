<?xml version="1.0" encoding="UTF-8"?>
<hqml xmlns="http://hone.hanwha.co.kr/schema/hqml"
	name="ls.ltm.testResultInqueryDAO">
	<desc>시험진행 및 결과 조회</desc>

	<!-- 시험접수목록 DATA를 조회한다. -->
	<statement name="selectList" type="select"><![CDATA[
/* 접수목록 조회 */ 
SELECT '0' AS CHK
     , A.REQ_NUM
     , A.REQ_DATE
     , A.ACCEPTNM
     , A.UPJANG_NM
     , A.ORG_NM
     , (SELECT COUNT(1)
          FROM LRM_SPECM_INFO B
         WHERE A.REQ_NUM = B.REQ_NUM) AS SPECM_CNT		/* 검체목록건수 */
     , (
        SELECT NVL(SUM(DECODE(Y.COMM_1_USE_YN, 'Y', SUM(Y.COMM_1), 0)) +
                   SUM(DECODE(Y.COMM_2_USE_YN, 'Y', SUM(Y.COMM_2), 0)) +
                   SUM(DECODE(Y.COMM_3_USE_YN, 'Y', SUM(Y.COMM_3), 0)) +
                   SUM(DECODE(Y.COMM_4_USE_YN, 'Y', SUM(Y.COMM_4), 0)) +
                   SUM(DECODE(Y.COMM_5_USE_YN, 'Y', SUM(Y.COMM_5), 0)), 0)
          FROM LRM_SPECM_INFO X
             , LRM_TEST_INFO Y
         WHERE 1 = 1
           AND X.REQ_NUM = A.REQ_NUM
           AND X.REQ_NUM = Y.REQ_NUM
           AND X.ACCEPT_NUM = Y.ACCEPT_NUM
           --AND X.COST_CLASS = '102' -- 유상
         GROUP BY Y.COMM_1_USE_YN, Y.COMM_2_USE_YN, Y.COMM_3_USE_YN, Y.COMM_4_USE_YN, Y.COMM_5_USE_YN
       ) AS COMM_TOT_AMT
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = A.CUSER) AS USER_NM		/* 접수자 */
     , (SELECT MAX(ACCEPTDD)
          FROM LRM_SPECM_INFO B
         WHERE A.REQ_NUM = B.REQ_NUM) AS ACCEPTDD		/* 접수일자 */
     , CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              'Y'
            ELSE
              'N'
       END AS COMPLETE_YN	/* 시험완료 여부 */
     , CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              (SELECT TO_CHAR(MAX(UDATE), 'YYYYMMDD')
                 FROM LTM_TEST_DIARY
                WHERE REQ_NUM = A.REQ_NUM)
            ELSE
              ''
       END AS COMPLETE_DD	/* 시험완료일자 */
     --, DECODE(A.INSPECT_RPT_ISSUE, NULL, 'N', A.INSPECT_RPT_ISSUE) AS INSPECT_RPT_ISSUE    /* 성적서 발급 여부 */
     ,  DECODE(NVL(A.INSPECT_RPT_ISSUE, 'N'), NULL, '0', (DECODE(NVL(A.INSPECT_RPT_ISSUE, 'N'), 'Y', '1', '0'))) AS INSPECT_RPT_ISSUE    /* 성적서 발급 여부 */
     , (
         SELECT COUNT(1)
           FROM LEM_INSPECT_RPT_ISSUE_LOG
          WHERE REQ_NUM = A.REQ_NUM
            AND PUBLISHDD IS NOT NULL
       ) AS PUBLISH_CNT	/* 발급횟수 */
     , U.PROC_CLASS AS PROGRESS_STATUS	/* 진행상태 */
     , U.PROC_REASON  /* 취소/반려사유 */
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = U.PROC_USER) AS PROC_USER_NM  /* 처리자 */
     , U.PROCDD  /* 처리일자 */
     , (
         SELECT MAX(SIGN_INSTANCE_ID)
           FROM LRM_ELCTNSIGN_INFO
          WHERE REQ_NUM = A.REQ_NUM
            AND SEQ = 1 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       ) AS SIGN_INSTANCE_ID	/* 전자결재 ID */
     , CASE WHEN EXISTS (
                        SELECT 1
                          FROM LRM_ELCTNSIGN_INFO
                         WHERE REQ_NUM = A.REQ_NUM
                           AND SEQ = 1 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
                        ) THEN
                 (SELECT NVL(SCC_SIGN_STATUS_FUN(MAX(SIGN_INSTANCE_ID)), 'DRAFT')	/* 결재상태가 1분정도 걸리기때문에 */
                    FROM LRM_ELCTNSIGN_INFO
                   WHERE REQ_NUM = A.REQ_NUM
                     AND SEQ = 1) /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       END AS SIGN_PROGRESS_STATUS    /* 전자결재 상태 */
     , (
         SELECT MAX(SIGN_INSTANCE_ID)
           FROM LRM_ELCTNSIGN_INFO
          WHERE REQ_NUM = A.REQ_NUM
            AND SEQ = 2 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       ) AS SIGN_INSTANCE_ID_NOTFIT	/* 전자결재 ID */
     , CASE WHEN EXISTS (
                        SELECT 1
                          FROM LRM_ELCTNSIGN_INFO
                         WHERE REQ_NUM = A.REQ_NUM
                           AND SEQ = 2 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
                        ) THEN
                 (SELECT NVL(SCC_SIGN_STATUS_FUN(MAX(SIGN_INSTANCE_ID)), 'DRAFT')	/* 결재상태가 1분정도 걸리기때문에 */
                    FROM LRM_ELCTNSIGN_INFO
                   WHERE REQ_NUM = A.REQ_NUM
                     AND SEQ = 2) /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       END AS SIGN_NOTFIT_PROGRESS_STATUS    /* 부적합 전자결재 상태 */
     , (
         SELECT MAX(SIGN_INSTANCE_ID)
           FROM LRM_ELCTNSIGN_INFO
          WHERE REQ_NUM = A.REQ_NUM
            AND SEQ = 3 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       ) AS SIGN_INSTANCE_ID_INSPTRPT	/* 전자결재 ID */
     , CASE WHEN EXISTS (
                        SELECT 1
                          FROM LRM_ELCTNSIGN_INFO
                         WHERE REQ_NUM = A.REQ_NUM
                           AND SEQ = 3 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
                        ) THEN
                 (SELECT NVL(SCC_SIGN_STATUS_FUN(MAX(SIGN_INSTANCE_ID)), 'DRAFT')	/* 결재상태가 1분정도 걸리기때문에 */
                    FROM LRM_ELCTNSIGN_INFO
                   WHERE REQ_NUM = A.REQ_NUM
                     AND SEQ = 3) /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       END AS SIGN_INSPTRPT_PROGRESS_STATUS    /* 성적서 전자결재 상태 */
     , (
         SELECT MAX(SIGN_INSTANCE_ID)
           FROM LRM_ELCTNSIGN_INFO
          WHERE REQ_NUM = A.REQ_NUM
            AND SEQ = 4 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       ) AS SIGN_INSTANCE_ID_RE_ISSUE   /* 전자결재 ID */
     , CASE WHEN EXISTS (
                        SELECT 1
                          FROM LRM_ELCTNSIGN_INFO
                         WHERE REQ_NUM = A.REQ_NUM
                           AND SEQ = 4 /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
                        ) THEN
                 (SELECT NVL(SCC_SIGN_STATUS_FUN(MAX(SIGN_INSTANCE_ID)), 'DRAFT')   /* 결재상태가 1분정도 걸리기때문에 */
                    FROM LRM_ELCTNSIGN_INFO
                   WHERE REQ_NUM = A.REQ_NUM
                     AND SEQ = 4) /* 1:최종결재, 2:부적합결재, 3:성적서발급결재, 4:성적서재발급결재 */
       END AS SIGN_PROGRESS_STATUS_RE_ISSUE    /* 성적서 전자결재 상태 */
     , (
        SELECT LI.RTN_MSG
          FROM (
                 SELECT REQ_NUM
                      , RTN_MSG
                      , ROW_NUMBER() OVER(PARTITION BY REQ_NUM ORDER BY REQ_NUM, SEQ DESC) AS RN
                   FROM LRM_IF_INFO
                  WHERE WORK_CLASS = 'LIMS'
                    AND IF_CLASS = 'SALS'
               ) LI
          WHERE LI.RN = 1
            AND LI.REQ_NUM = A.REQ_NUM
       ) AS SALS_RTN_MSG
  FROM LRM_TEST_REQ_ACCEPT A
     , (
        SELECT PD.REQ_NUM
             , PD.PROC_USER
             , PD.PROCDD
             , PD.PROC_REASON
             , PD.PROC_CLASS
             , PD.SEQ
          FROM (
                SELECT Y.REQ_NUM
                     , Y.PROC_USER
                     , Y.PROCDD
                     , Y.PROC_REASON
                     , Y.PROC_CLASS
                     , Y.SEQ
                     , ROW_NUMBER() OVER (PARTITION BY Y.REQ_NUM ORDER BY Y.REQ_NUM, Y.SEQ DESC) AS RN
                  FROM LRM_PROC_DESC Y
               ) PD
         WHERE RN = 1
       ) U
 WHERE 1 = 1
   AND A.REQ_NUM = U.REQ_NUM(+)
<#if toDay?has_content> AND A.REQ_DATE BETWEEN :fromDay AND :toDay </#if>
<#if toDayTest?has_content>
   AND EXISTS (SELECT 1
                 FROM LTM_TEST_DIARY
                WHERE A.REQ_NUM = REQ_NUM
                  AND TESTDD BETWEEN :fromDayTest AND :toDayTest)
</#if>
<#if specmNm?has_content>
   AND EXISTS (SELECT 1
                 FROM LRM_SPECM_INFO
                WHERE A.REQ_NUM = REQ_NUM
                  AND SPECM_NM LIKE '%' || :specmNm || '%')
</#if>
<#if testArticleNm?has_content>
   AND EXISTS (SELECT 1
                 FROM LRM_TEST_INFO TI
                    , LCM_TEST_ARTICLE TA
                WHERE A.REQ_NUM = TI.REQ_NUM
                  AND TI.ARTICLE_CD = TA.ARTICLE_CD
                  AND TA.ARTICLE_NM LIKE '%' || :testArticleNm || '%')
</#if>
<#if testUser?has_content>
   AND EXISTS (SELECT 1
                 FROM LRM_TEST_INFO TI
                WHERE A.REQ_NUM = TI.REQ_NUM
                  AND TI.SABUN = :testUser)
</#if>
<#if writeYn?has_content>
   AND CASE WHEN EXISTS (SELECT 1
                           FROM LTM_TEST_DIARY
                          WHERE A.REQ_NUM = REQ_NUM)
            THEN
              'Y'
            ELSE
              'N'
       END = :writeYn
</#if>
<#if endYn?has_content>
   AND CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              'Y'
            ELSE
              'N'
       END = :endYn
</#if>
<#if progressStatus?has_content> AND U.PROC_CLASS = :progressStatus </#if>
 ORDER BY A.REQ_NUM DESC
        ]]></statement>

	<!-- 시험진행 및 결과 목록 DATA를 조회한다. -->
	<statement name="selectSpecmList" type="select"><![CDATA[
/* 접수 등록 후 의뢰번호로 검체정보 조회 */
SELECT '0' CHK,
       A.REQ_NUM,
       A.ACCEPT_NUM,
       A.ACCEPTDD,
       A.SPECM_CLASS,
       A.SPECM_CD,
       A.SPECM_NM,
       A.SPECM_TYPE,
       A.MGRP_CD,
       A.MCALSS_CD,
       A.SCLASS_CD,
       ((SELECT X.MGRP_NM FROM LCM_SPECM_TYPE_MGRP X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.MGRP_CD = A.MGRP_CD) || ' / ' ||
        (SELECT X.MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.MCALSS_CD = A.MCALSS_CD) || ' / ' ||
        (SELECT X.SCLASS_NM FROM LCM_SPECM_TYPE_SCLASS X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.SCLASS_CD = A.SCLASS_CD))
       AS SPECM_TYPE_NM,				/* 검체 유형명 ( 대분류명 / 중분류명 / 소분류명 ) */
       SCC_CODE_NM('SPECM_TYPE_PCLS', A.SPECM_TYPE_PCLS) AS SPECM_TYPE_PCLS_NM,	/* 세부 검체 유형 */
       A.SPECM_TYPE_PCLS,
       A.COST_CLASS,					/* 비용 */
       SCC_CODE_NM('COST_CLASS', A.COST_CLASS) AS COST_CLASS_NM,
       A.INSPT_MTOD,					/* 검사방법 */
       SCC_CODE_NM('INSPT_MTOD', A.INSPT_MTOD) AS INSPT_MTOD_NM,
       A.INSPT_CLASS,					/* 검사구분 */
       SCC_CODE_NM('INSPT_CLASS', A.INSPT_CLASS) AS INSPT_CLASS_NM,
       A.INSPT_PURP_1,					/* 검사목적1 */
       SCC_CODE_NM('INSPT_PURP_1', A.INSPT_PURP_1) AS INSPT_PURP_1_NM,
       A.INSPT_PURP_2,					/* 검사목적2 */
       SCC_CODE_NM('INSPT_PURP_2', A.INSPT_PURP_2) AS INSPT_PURP_2_NM,
       A.INSPT_PURP_3,					/* 검사목적3 */
       SCC_CODE_NM('INSPT_PURP_3', A.INSPT_PURP_3) AS INSPT_PURP_3_NM,
       A.SPECM_WTRLST_NM,               /* 검체물성 */
       SCC_CODE_NM('SPECM_WTRLST_NM', A.SPECM_WTRLST_NM) SPECM_WTRLST_NM_NM,
       A.LONGSTORAGE_YN,                /* 장기보존여부 */
       SCC_CODE_NM('LONGSTORAGE_YN', A.LONGSTORAGE_YN) AS LONGSTORAGE_YN_NM,
       A.INSPTBEFORE_SPECM_STATUS,      /* 검사전검체상태 */
       SCC_CODE_NM('INSPTBEFORE_SPECM_STATUS', A.INSPTBEFORE_SPECM_STATUS) AS INSPTBEFORE_SPECM_STATUS_NM,
       A.PICK_STATUS,                   /* 채취상태 */
       SCC_CODE_NM('PICK_STATUS', A.PICK_STATUS) AS PICK_STATUS_NM,
       A.INSPT_OBJ_1,                   /* 검사대상1 */
       SCC_CODE_NM('INSPT_OBJ_1', INSPT_OBJ_1) AS INSPT_OBJ_1_NM,
       A.INSPT_OBJ_2,                   /* 검사대상2 */
       SCC_CODE_NM('INSPT_OBJ_2', A.INSPT_OBJ_2) AS INSPT_OBJ_2_NM,
       A.INSPT_OBJ_3,                   /* 검사대상3 */
       SCC_CODE_NM('INSPT_OBJ_3', A.INSPT_OBJ_3) AS INSPT_OBJ_3_NM,
       A.INSPT_OBJ_4,                   /* 검사대상4 */
       SCC_CODE_NM('INSPT_OBJ_4', A.INSPT_OBJ_4) AS INSPT_OBJ_4_NM,
       A.MFGWON,                        /* 제조원 */
       A.DTR_VENDOR,                    /* 유통업체 */
       A.ACCEPTCITY_TEMPR,              /* 접수시품온 */
       A.STAND,                         /* 규격 */
       A.UNIT,                          /* 단위 */
       A.ORIGIN,                        /* 원산지 */
       A.CHARG_BASIS,                   /* 보관기준 */
       SCC_CODE_NM('CHARG_BASIS', A.CHARG_BASIS) AS CHARG_BASIS_NM,
       A.MFGDD,
       A.DTRLIMT,
       A.DTRLIMT_MTS,
       A.DTRLIMT_DD,
       A.SPECM_DELIVER_PCLSFACT,
       A.PROGRESS_STATUS,
       A.NOT_FIT_CLSFI,
       --SCC_CODE_NM('NOT_FIT_CLSFI', A.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM,
       C.INSPT_FLD_NM || '/' || C.NOT_FIT_CLSFI_NM AS NOT_FIT_CLSFI_NM,    /* 검사분야 / 부적합분류 */
       A.LAST_DECISION,
       (
        SELECT LI.RTN_MSG || '(' || LM.SEND_INFO || ')'
          FROM (
                 SELECT REQ_NUM
                      , RTN_MSG
                      , ROW_NUMBER() OVER(PARTITION BY REQ_NUM ORDER BY REQ_NUM, SEQ DESC) AS RN
                   FROM LRM_IF_INFO
                  WHERE WORK_CLASS = 'LIMS'
                    AND IF_CLASS = 'ITEM'
               ) LI
             , LRM_MATERIAL_INFO LM
          WHERE LI.RN = 1
            AND LI.REQ_NUM = A.REQ_NUM
            AND LI.REQ_NUM = LM.REQ_NUM
            AND LM.ACCEPT_NUM = A.ACCEPT_NUM
            AND LM.SPECM_CD = A.SPECM_CD
       ) AS ITEM_SEND_INFO,
       A.CUSER,
       A.CDATE,
       A.UUSER,
       A.UDATE,
       DECODE(A.DISUSE_YN, 'Y', '1', '0') AS DISUSE_YN,		/* 폐기 여부 */
       A.DISUSE_DATE,	/* 폐기 일자 */
       SCC_CODE_NM('URGENT_YN', A.MFG_VENDOR) AS URGENT_YN  /* 긴급여부 */
FROM   LRM_SPECM_INFO A
     , (
        SELECT NF.REQ_NUM
             , NF.ACCEPT_NUM
             , NF.INSPT_FLD_NM
             , NF.NOT_FIT_CLSFI_NM
          FROM (
                 SELECT /*+ INDEX_FFS(Y) */
                        Y.REQ_NUM
                      , Y.ACCEPT_NUM
                      , P.INSPT_FLD
                      , SCC_CODE_NM('INSPT_FLD', P.INSPT_FLD) AS INSPT_FLD_NM
                      , Y.LAST_DECISION
                      , P.ARTICLE_NM
                      , P.NOT_FIT_CLSFI
                      , SCC_CODE_NM('NOT_FIT_CLSFI', P.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM
                      , ROW_NUMBER() OVER(PARTITION BY Y.REQ_NUM, Y.ACCEPT_NUM ORDER BY Y.REQ_NUM, Y.ACCEPT_NUM, P.NOT_FIT_CLSFI DESC) AS RN
                   FROM LTM_TEST_DIARY Y
                      , LCM_TEST_ARTICLE P
                  WHERE 1 = 1
                    AND Y.REQ_NUM = :reqNum
                    AND Y.ARTICLE_CD = P.ARTICLE_CD
                    --AND Y.LAST_DECISION <> '101'
                    AND Y.LAST_DECISION = '102'
               ) NF
         WHERE NF.RN = 1
       ) C
WHERE  A.REQ_NUM = :reqNum
  AND  A.REQ_NUM = C.REQ_NUM(+)
  AND  A.ACCEPT_NUM = C.ACCEPT_NUM(+)
<#if specmNm?has_content>
   AND A.SPECM_NM LIKE '%' || :specmNm || '%'
</#if>
ORDER BY A.ACCEPT_NUM
        ]]></statement>

	<!-- 시험항목 목록 DATA를 조회한다. -->
	<statement name="selectDetailList" type="select"><![CDATA[
/* 시험항목 목록 조회 */
SELECT A.REQ_NUM	/* 의뢰번호 */
     , A.ACCEPT_NUM	/* 접수번호 */
     , A.ARTICLE_CD	/* 시험항목 */
     , C.ARTICLE_NM	/* 시험항목명 */
     , SCC_CODE_NM('INSPT_FLD', A.INSPT_FLD) AS INSPT_FLD_NM	/* 검사분야명 */
     , SCC_CODE_NM('NOT_FIT_CLSFI', C.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM	/* 부적합분류명 */
     , B.TESTDD	/* 시험일자 */
     , A.SABUN	/* 담당자사번 */
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = A.SABUN) AS USER_NM		/* 담당자 */
     , B.TECHRESP_USER	/* 기술책임자 */
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = B.TECHRESP_USER) AS TECHRESP_USER_NM		/* 기술책임자명 */
     , A.BASIS_STAND      /* 기준규격 */
     , B.RESULT	/* 결과 */
     , B.DECISION	/* 판정 */
     , B.LAST_DECISION	/* 최종 판정 */
     , CASE WHEN B.LAST_DECISION IS NOT NULL THEN
             /* TO_CHAR(B.UDATE, 'YYYYMMDD') */
              (SELECT TO_CHAR(MAX(V.UDATE), 'YYYYMMDD') 
                 FROM LTM_TEST_DIARY V
                WHERE V.REQ_NUM = B.REQ_NUM 
                  AND V.ACCEPT_NUM = B.ACCEPT_NUM  
                GROUP BY ACCEPT_NUM) 
            ELSE
              ''
       END AS COMPLETE_DD	/* 시험완료일자 */
     , (CASE WHEN EXISTS (SELECT 1
                            FROM LTM_TEST_DIARY
                           WHERE REQ_NUM = A.REQ_NUM
                             AND ACCEPT_NUM = A.ACCEPT_NUM
                             AND ARTICLE_CD = B.ARTICLE_CD
                             AND SABUN = A.SABUN) THEN
           'Y'
       ELSE
           'N'
       END) AS DIARY_WRITE_YN	/* 시험일지 작성 여부 */
     , CASE WHEN U.PROC_CLASS >= '200' THEN	/* 시험완료 승인 */
          'Y'
       ELSE
          'N'
       END AS COMPLETE_YN	/* 시험완료승인 */
     , NVL(A.LEGAL_BASIS, 'N') AS LEGAL_BASIS
     , NVL(A.INSIDE_BASIS, 'N') AS INSIDE_BASIS
     , A.JOB_ORDER
     , DECODE(A.TEST_CLASS, 'TEST', '시험항목', '장기보존') AS TEST_CLASS
     , C.TEST_MTOD
     , '(' || (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL) || ' / ' || (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) || ')' PROGRESS_TOTSTS
     , '(' || (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND ACCEPT_NUM = A.ACCEPT_NUM AND LAST_DECISION IS NOT NULL) || ' / ' || (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM AND ACCEPT_NUM = A.ACCEPT_NUM) || ')' PROGRESS_STS
  FROM LRM_TEST_INFO A
     , LTM_TEST_DIARY B
     , (
        SELECT PD.REQ_NUM
             , PD.PROC_USER
             , PD.PROCDD
             , PD.PROC_REASON
             , PD.PROC_CLASS
             , PD.SEQ
          FROM (
                SELECT Y.REQ_NUM
                     , Y.PROC_USER
                     , Y.PROCDD
                     , Y.PROC_REASON
                     , Y.PROC_CLASS
                     , Y.SEQ
                     , ROW_NUMBER() OVER (PARTITION BY Y.REQ_NUM ORDER BY Y.REQ_NUM, Y.SEQ DESC) AS RN
                  FROM LRM_PROC_DESC Y
               ) PD
         WHERE RN = 1
       ) U
     , LCM_TEST_ARTICLE C
 WHERE 1 = 1
   AND A.REQ_NUM = B.REQ_NUM(+)
   AND A.REQ_NUM = U.REQ_NUM(+)
   AND A.ACCEPT_NUM = B.ACCEPT_NUM(+)
   AND A.REQ_NUM = :reqNum
   AND A.ACCEPT_NUM = :acceptNum
   AND A.ARTICLE_CD = B.ARTICLE_CD(+)
   AND A.SABUN = B.SABUN(+)
   AND A.ARTICLE_CD = C.ARTICLE_CD(+)
<#if toDayTest?has_content>
   AND B.TESTDD BETWEEN :fromDayTest AND :toDayTest
</#if>
<#if testArticleNm?has_content>
   AND EXISTS (SELECT 1
                 FROM LCM_TEST_ARTICLE TA
                WHERE A.ARTICLE_CD = TA.ARTICLE_CD
                  AND TA.ARTICLE_NM LIKE '%' || :testArticleNm || '%')
</#if>
<#if insptFld?has_content>
   AND A.INSPT_FLD = :insptFld
</#if>
<#if testUser?has_content>
   AND A.SABUN = :testUser
</#if>
<#if writeYn?has_content>
   AND CASE WHEN EXISTS (SELECT 1
                           FROM LTM_TEST_DIARY
                          WHERE A.REQ_NUM = REQ_NUM)
            THEN
              'Y'
            ELSE
              'N'
       END = :writeYn
</#if>
<#if endYn?has_content>
   AND CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              'Y'
            ELSE
              'N'
       END = :endYn
</#if>
 ORDER BY A.ARTICLE_CD
        ]]></statement>

	<!-- 시험일지 DATA를 조회한다. -->
	<statement name="selectTestDiary" type="select">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectTestDiary */
		<![CDATA[
/*  시험일지 조회 */
SELECT A.REQ_NUM
     , A.REQ_DATE
     , B.ACCEPT_NUM
     , A.UPJANG_NM
     , A.ORG_NM
     , TO_CHAR(TO_DATE(B.ACCEPTDD, 'YYYY-MM-DD'), 'YYYY-MM-DD') AS ACCEPTDD
     , D.TESTDD
     , B.SPECM_NM
     , ((SELECT X.MGRP_NM FROM LCM_SPECM_TYPE_MGRP X WHERE X.SPECM_TYPE = B.SPECM_TYPE AND X.MGRP_CD = B.MGRP_CD) || ' / ' ||
        (SELECT X.MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS X WHERE X.SPECM_TYPE = B.SPECM_TYPE AND X.MCALSS_CD = B.MCALSS_CD) || ' / ' ||
        (SELECT X.SCLASS_NM FROM LCM_SPECM_TYPE_SCLASS X WHERE X.SPECM_TYPE = B.SPECM_TYPE AND X.SCLASS_CD = B.SCLASS_CD))
       AS SPECM_TYPE_NM				/* 검체 유형명 ( 대분류명 / 중분류명 / 소분류명 ) */
     , (SELECT ARTICLE_NM FROM LCM_TEST_ARTICLE WHERE C.ARTICLE_CD = ARTICLE_CD) AS ARTICLE_NM	/* 시험항목명 */
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = A.CUSER) AS USER_NM    /* 접수자 */
     , D.LAST_DECISION
     , C.BASIS_STAND
     , D.RESULT
     , C.SABUN
     , (SELECT X.NM_KOR
          FROM SCC_USERINFO X
         WHERE X.SABUN = C.SABUN) AS PROC_USER_NM    /* 담당자 */
     , D.DECISION
     , D.REMARK
     , D.LAB_BOOK
     , D.TECHRESP_USER
     , D.REF_SEQ
     , CASE WHEN U.PROC_CLASS >= '200' THEN	/* 시험완료 승인 */
          'Y'
       ELSE
          'N'
       END AS COMPLETE_YN	/* 시험완료승인 */
  FROM LRM_TEST_REQ_ACCEPT A
     , LRM_SPECM_INFO B
     , LRM_TEST_INFO C
     , LTM_TEST_DIARY D
     , (
        SELECT PD.REQ_NUM
             , PD.PROC_USER
             , PD.PROCDD
             , PD.PROC_REASON
             , PD.PROC_CLASS
             , PD.SEQ
          FROM (
                SELECT Y.REQ_NUM
                     , Y.PROC_USER
                     , Y.PROCDD
                     , Y.PROC_REASON
                     , Y.PROC_CLASS
                     , Y.SEQ
                     , ROW_NUMBER() OVER (PARTITION BY Y.REQ_NUM ORDER BY Y.REQ_NUM, Y.SEQ DESC) AS RN
                  FROM LRM_PROC_DESC Y
               ) PD
         WHERE RN = 1
       ) U
 WHERE 1 = 1
   AND A.REQ_NUM = :reqNum
   AND A.REQ_NUM = U.REQ_NUM(+)
   AND A.REQ_NUM = B.REQ_NUM
   AND A.REQ_NUM = C.REQ_NUM
   AND B.ACCEPT_NUM = :acceptNum
   AND B.ACCEPT_NUM = C.ACCEPT_NUM
   AND C.ARTICLE_CD = :articleCd
   AND C.REQ_NUM = D.REQ_NUM(+)
   AND C.ACCEPT_NUM = D.ACCEPT_NUM(+)
   AND C.ARTICLE_CD = D.ARTICLE_CD(+)
   AND C.SABUN = :sabun
   AND C.SABUN = D.SABUN(+)
        ]]>
	</statement>

	<!-- 시험일지 시험방법 DATA를 조회한다. -->
	<statement name="selectTestDiaryMethodList" type="select">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectTestDiaryMethodList
		*/
		<![CDATA[
/*  시험일지 시험방법 조회 */
SELECT A.REQ_NUM
     , A.ACCEPT_NUM
     , A.ARTICLE_CD
     , A.SABUN
     , A.SEQ
     , A.TEST_METHOD
  FROM LTM_TEST_DIARY_TEST_METHOD A
 WHERE 1 = 1
   AND A.REQ_NUM = :reqNum
   AND A.ACCEPT_NUM = :acceptNum
   AND A.ARTICLE_CD = :articleCd
   AND A.SABUN = :sabun
        ]]>
	</statement>

	<!-- 시험일지 시험방법 DATA를 시험항목에서 조회한다. -->
	<statement name="selectTestDiaryMethodArticleList" type="select">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectTestDiaryMethodArticleList
		*/
		<![CDATA[
/*  시험일지 시험방법 조회 */
SELECT :reqNum AS REQ_NUM
     , :acceptNum AS ACCPET_NUM
     , :articleCd AS ARTICLE_CD
     , :sabun AS SABUN
     , 1 AS SEQ
     , A.TEST_MTOD AS TEST_METHOD
  FROM LCM_TEST_ARTICLE A
 WHERE 1 = 1
   AND A.ARTICLE_CD = :articleCd
        ]]>
	</statement>

	<!-- 시험일지 Master를 생성한다. -->
	<statement name="insertTestArticleList" type="insert">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.insertTestArticleList
		*/
		<![CDATA[
/* 시험일지 MASTER 생성 */
INSERT INTO LTM_TEST_DIARY
(
 REQ_NUM,
 ACCEPT_NUM,
 ARTICLE_CD,
 DIARY_NUM,
 SABUN,
 TESTDD,
 EDATE,
 RESULT,
 DECISION,
 LAST_DECISION,
 REMARK,
 LAB_BOOK,
 TECHRESP_USER,
 CUSER,
 CDATE,
 UUSER,
 UDATE,
 REF_SEQ
) VALUES (
 :reqNum,
 :acceptNum,
 :articleCd,
 '1',
 :sabun,
<#if testdd?exists> :testdd, <#else> null, </#if>
<#if edate?exists> :edate, <#else> null, </#if>
<#if result?exists> :result, <#else> null, </#if>
<#if decision?exists> :decision, <#else> null, </#if>
<#if lastDecision?exists> :lastDecision, <#else> null, </#if>
<#if remark?exists> :remark, <#else> null, </#if>
<#if labBook?exists> :labBook, <#else> null, </#if>
<#if techrespUser?exists> :techrespUser, <#else> null, </#if>
 :loginSabun,
 SYSDATE,
 :loginSabun,
 SYSDATE,
<#if refSeq?exists> :refSeq <#else> null </#if>
)
        ]]>
	</statement>

	<!-- 시험일지 건수를 조회 한다. -->
	<statement name="selectTestDiaryCnt" type="select">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectTestDiaryCnt
		*/
		<![CDATA[
/* 시험일지르 조회 */
SELECT COUNT(1)
  FROM LTM_TEST_DIARY A
 WHERE A.REQ_NUM = :reqNum
--   AND A.ACCEPT_NUM = :acceptNum
--  AND A.ARTICLE_CD = :articleCd
--   AND A.DIARY_NUM = '1'
--   AND A.SABUN = :sabun
        ]]>
	</statement>

	<!-- 시험일지 Master를 수정한다. -->
	<statement name="updateTestArticleList" type="update">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.updateTestArticleList
		*/
		<![CDATA[
/* 시험일지 MASTER 수정 */
MERGE INTO LTM_TEST_DIARY A
USING DUAL
ON (
A.REQ_NUM = :reqNum
AND    A.ACCEPT_NUM = :acceptNum
AND    A.ARTICLE_CD = :articleCd
AND    A.DIARY_NUM = '1'
AND    A.SABUN = :sabun
)
WHEN MATCHED THEN
    UPDATE SET
        <#if testdd?exists> A.TESTDD = :testdd, </#if>
        <#if edate?exists> A.EDATE = :edate, </#if>
        <#if result?exists> A.RESULT = :result, </#if>
        <#if decision?exists> A.DECISION = :decision, </#if>
        <#if lastDecision?exists> A.LAST_DECISION = :lastDecision, </#if>
        <#if remark?exists> A.REMARK = :remark, </#if>
        <#if labBook?exists> A.LAB_BOOK = :labBook, </#if>
        <#if techrespUser?exists> A.TECHRESP_USER = :techrespUser, </#if>
               A.UUSER = :loginSabun,
               A.UDATE = SYSDATE,
        <#if refSeq?exists> A.REF_SEQ = :refSeq </#if>
WHEN NOT MATCHED THEN
    INSERT (
         REQ_NUM,
         ACCEPT_NUM,
         ARTICLE_CD,
         DIARY_NUM,
         SABUN,
         TESTDD,
         EDATE,
         RESULT,
         DECISION,
         LAST_DECISION,
         REMARK,
         LAB_BOOK,
         TECHRESP_USER,
         CUSER,
         CDATE,
         UUSER,
         UDATE,
         REF_SEQ
        ) VALUES (
         :reqNum,
         :acceptNum,
         :articleCd,
         '1',
         :sabun,
        <#if testdd?exists> :testdd, <#else> null, </#if>
        <#if edate?exists> :edate, <#else> null, </#if>
        <#if result?exists> :result, <#else> null, </#if>
        <#if decision?exists> :decision, <#else> null, </#if>
        <#if lastDecision?exists> :lastDecision, <#else> null, </#if>
        <#if remark?exists> :remark, <#else> null, </#if>
        <#if labBook?exists> :labBook, <#else> null, </#if>
        <#if techrespUser?exists> :techrespUser, <#else> null, </#if>
         :loginSabun,
         SYSDATE,
         :loginSabun,
         SYSDATE,
        <#if refSeq?exists> :refSeq <#else> null </#if>
    )
        ]]>
	</statement>

	<!-- 시험일지 시험방법을 생성 한다. -->
	<statement name="insertTestDiaryList" type="insert">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.insertTestDiaryList
		*/
		<![CDATA[
/* 시험일지 시험방법 생성 */
INSERT INTO LTM_TEST_DIARY_TEST_METHOD
(
 REQ_NUM,
 ACCEPT_NUM,
 ARTICLE_CD,
 DIARY_NUM,
 SABUN,
 SEQ,
 TEST_METHOD
)
SELECT :reqNum,
       :acceptNum,
       :articleCd,
       '1',
       :sabun,
       (
        SELECT NVL(MAX(SEQ),0) + 1
          FROM LTM_TEST_DIARY_TEST_METHOD
         WHERE REQ_NUM = :reqNum
           AND ACCEPT_NUM = :acceptNum
           AND ARTICLE_CD = :articleCd
           AND DIARY_NUM = '1'
           AND SABUN = :sabun
       ),
       <#if testMethod?exists> :testMethod <#else> null </#if>
  FROM DUAL
        ]]>
	</statement>

	<!-- 시험일지 시험방법을 수정 한다. -->
	<statement name="updateTestDiaryList" type="update">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.updateTestDiaryList
		*/
		<![CDATA[
/* 시험일지 시험방법 수정 */
UPDATE LTM_TEST_DIARY_TEST_METHOD SET
<#if testMethod?exists> TEST_METHOD = :testMethod </#if>
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
AND    ARTICLE_CD = :articleCd
AND    SABUN = :sabun
AND    SEQ = :seq
        ]]>
	</statement>

	<!-- 시험일지 시험방법을 삭제 한다. -->
	<statement name="deleteTestDiaryList" type="delete">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.deleteTestDiaryList
		*/
		<![CDATA[
/* 시험일지 시험방법 삭제 */
DELETE
FROM   LTM_TEST_DIARY_TEST_METHOD
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
AND    ARTICLE_CD = :articleCd
AND    SABUN = :sabun
AND    SEQ = :seq
        ]]>
	</statement>

	<!-- 시험일지 시험방법을 삭제 한다. -->
	<statement name="deleteAllTestDiaryList" type="delete">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.deleteAllTestDiaryList
		*/
		<![CDATA[
/* 시험일지 시험방법 삭제 */
DELETE
FROM   LTM_TEST_DIARY_TEST_METHOD
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
AND    ARTICLE_CD = :articleCd
AND    SABUN = :sabun
        ]]>
	</statement>

	<!-- 시험일지의 최종판정이 완료되었는지 여부를 조회 한다. -->
	<statement name="selectTestDiaryEndYn" type="select">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectTestDiaryEndYn */
		<![CDATA[
/* 시험일지의 최종판정이 완료되었는지 여부 조회 */
SELECT CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = :reqNum) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = :reqNum AND LAST_DECISION IS NOT NULL)
            THEN
              'Y'
            ELSE
              'N'
       END AS COMPLETE_YN
  FROM DUAL
        ]]>
	</statement>

	<!-- 최종 진행상태를 조회 한다. -->
	<statement name="selectLastProgressStatus" type="select">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectLastProgressStatus
		*/
		<![CDATA[
/* 최종 진행상태를 조회 */
SELECT PD.REQ_NUM
     , PD.PROC_USER
     , PD.PROCDD
     , PD.PROC_REASON
     , PD.PROC_CLASS
     , PD.SEQ
  FROM (
        SELECT Y.REQ_NUM
             , Y.PROC_USER
             , Y.PROCDD
             , Y.PROC_REASON
             , Y.PROC_CLASS
             , Y.SEQ
             , ROW_NUMBER() OVER (PARTITION BY Y.REQ_NUM ORDER BY Y.REQ_NUM, Y.SEQ DESC) AS RN
          FROM LRM_PROC_DESC Y
       ) PD
 WHERE PD.RN = 1
   AND PD.REQ_NUM = :reqNum
        ]]>
	</statement>

	<!-- 시험결과 상신 전 검사목적,방법을 등록한다. -->
	<statement name="saveInsptPurpMtod" type="insert">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveInsptPurpMtod
		*/
		<![CDATA[
/* 시험결과 상신 전 검사목적,방법을 등록한다. */
INSERT INTO LRM_ELCTNSIGN_INFO (
    REQ_NUM
  , SEQ
  <#if signInstanceId?exists>, SIGN_INSTANCE_ID </#if>
  , INSPT_PURP
  <#if insptMtod?exists>, INSPT_MTOD </#if>
  <#if acceptNum?exists>, ACCEPT_NUM </#if>
  , CUSER
  , CDATE
  , UUSER
  , UDATE
)
SELECT :reqNum
     , :draftGubun	/* 1:일반결재, 2:부적합결재, 3:시험성적서 발급 결재, 4:성적서재발급 결재, 5:시험결과 구매 전송 */
     <#if signInstanceId?exists>, :signInstanceId </#if>
     , :insptPurp
     <#if insptMtod?exists>, :insptMtod </#if>
     <#if acceptNum?exists>, :acceptNum </#if>
     , :loginSabun
     , SYSDATE
     , :loginSabun
     , SYSDATE
  FROM DUAL
        ]]>
	</statement>

	<!-- 시험결과 구매전송 검사목적,방법을 등록한다. -->
	<statement name="saveInsptPurpMtodItemSend" type="insert">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveInsptPurpMtodItemSend
		*/
		<![CDATA[
/* 시험결과 구매전송 검사목적,방법을 등록한다. */
MERGE INTO LRM_ELCTNSIGN_INFO A
USING DUAL
ON (
    A.REQ_NUM = :reqNum
    AND A.SEQ = :draftGubun
    AND A.ACCEPT_NUM = :acceptNum
)
WHEN MATCHED THEN
    UPDATE SET
      <#if signInstanceId?exists>A.SIGN_INSTANCE_ID = :signInstanceId, </#if>
      A.INSPT_PURP = :insptPurp,
      <#if insptMtod?exists>A.INSPT_MTOD = :insptMtod, </#if>
      A.UUSER = :loginSabun,
      A.UDATE = SYSDATE
WHEN NOT MATCHED THEN
    INSERT (
        REQ_NUM
      , SEQ
      <#if signInstanceId?exists>, SIGN_INSTANCE_ID </#if>
      , INSPT_PURP
      <#if insptMtod?exists>, INSPT_MTOD </#if>
      <#if acceptNum?exists>, ACCEPT_NUM </#if>
      , CUSER
      , CDATE
      , UUSER
      , UDATE
    ) VALUES (
        :reqNum
      , :draftGubun  /* 1:일반결재, 2:부적합결재, 3:시험성적서 발급 결재, 4:성적서재발급 결재, 5:시험결과 구매 전송 */
      <#if signInstanceId?exists>, :signInstanceId </#if>
      , :insptPurp
      <#if insptMtod?exists>, :insptMtod </#if>
      <#if acceptNum?exists>, :acceptNum </#if>
      , :loginSabun
      , SYSDATE
      , :loginSabun
      , SYSDATE
    )
        ]]>
	</statement>

	<!-- 시험결과 상신 ID를 등록한다. -->
	<statement name="saveSignInstanceId" type="update">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveSignInstanceId
		*/
		<![CDATA[
/* 시험결과 상신 ID를 등록한다. */
UPDATE LRM_ELCTNSIGN_INFO SET
       SIGN_INSTANCE_ID = :signInstanceId
 WHERE REQ_NUM = :reqNum
 <#if acceptNum?exists>    AND ACCEPT_NUM = :acceptNum </#if>
 <#if draftGubun?exists>    AND SEQ = :draftGubun </#if>
   AND SIGN_INSTANCE_ID IS NULL
        ]]>
	</statement>

	<!-- 시험결과 상신 Master를 조회한다. -->
	<statement name="selectReportMst" type="select"><![CDATA[
/* 시험결과 상신 Master를 조회한다. */
SELECT A.UPJANG_NM || ' > ' ||
       B.INSPT_OBJ_1_NM || ' > ' || B.INSPT_OBJ_2_NM AS INSPT_OBJ /* 검사분류 */
     --2018.06.04 김명섭 LIMS개선
     --, TO_CHAR(TO_DATE(B.ACCEPTDD, 'YYYYMMDD'), 'YYYY. MM. DD') AS ACCEPTDD    /* 접수일자 */
     , TO_CHAR(TO_DATE(A.REQ_DATE, 'YYYYMMDD'), 'YYYY. MM. DD') AS ACCEPTDD
     , B.SPECM_NM || ' 외(' ||
       (
         SELECT COUNT(1) - 1
           FROM LRM_SPECM_INFO
          WHERE REQ_NUM = A.REQ_NUM
       )
       || ')' AS SPECM_NM /* 검사시료 */
     , ( C.INSPT_OBJ_3 || ' : ' ||C.SPECM_TYPE_NM ) AS INSPT_OBJ_3
     , CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              TO_CHAR(TO_DATE((SELECT MAX(TESTDD)
                 FROM LTM_TEST_DIARY
                WHERE REQ_NUM = A.REQ_NUM), 'YYYYMMDD'), 'YYYY. MM. DD')
            ELSE
              TO_CHAR(TO_DATE((SELECT MAX(TESTDD)
                 FROM LTM_TEST_DIARY
                WHERE REQ_NUM = A.REQ_NUM), 'YYYYMMDD'), 'YYYY. MM. DD')	/* 부적합상신때문에 추가 */
       END AS COMPLETE_DD    /* 시험완료일자 */
     , (
         SELECT COUNT(1)
           FROM LTM_TEST_DIARY
          WHERE REQ_NUM = A.REQ_NUM
            AND LAST_DECISION IN ('101','103')
       ) AS FIT_CNT           /* 적합건수 */
     , (
         SELECT COUNT(1)
           FROM LTM_TEST_DIARY
          WHERE REQ_NUM = A.REQ_NUM
            AND LAST_DECISION = '102'
       ) AS NOT_FIT_CNT       /* 부적합건수 */
     --2019.07.02 김명섭
     , (
         (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) - 
         (SELECT COUNT(1) FROM LTM_TEST_DIARY T1, LRM_TEST_INFO T2
          WHERE T1.REQ_NUM = T2.REQ_NUM
            AND T1.ACCEPT_NUM = T2.ACCEPT_NUM
            AND T1.ARTICLE_CD = T2.ARTICLE_CD
            AND T1.REQ_NUM = A.REQ_NUM) 
       ) AS HOLD_CNT
       --추가 20170414
            , DECODE( (
         SELECT COUNT(1)
           FROM LTM_TEST_DIARY
          WHERE REQ_NUM = A.REQ_NUM
            AND LAST_DECISION IN ('102')
              ),0,   CASE WHEN TO_CHAR(SYSDATE,'MM') BETWEEN '07' AND '12' THEN
            --부적합 횟수 계산 기준 변경 요청자:김민채  처리자:맹수영 20160704 (CH201607_00051)
            --CASE WHEN SUBSTR(A.ACCEPTDD,5,2) BETWEEN '07' AND '12' THEN
                (
                 SELECT COUNT(1)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPTV X
                  WHERE  P.REQ_NUM = X.REQ_NUM
                --    AND A.REQ_NUM = X.REQ_NUM
                   AND P.SPECM_CD IN (SELECT  SPECM_CD 
                                        FROM LRM_SPECM_INFO Z
                                       WHERE Z.REQ_NUM = A.REQ_NUM )
                   AND A.UPJANG = X.UPJANG
                   AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    --AND P.ACCEPT_NUM = A.ACCEPT_NUM
                --    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD BETWEEN TO_CHAR(SYSDATE,'YYYY')||'0101' AND TO_CHAR(SYSDATE,'YYYY')||'1231'
                    AND EXISTS (
                                SELECT 1
                                  FROM LTM_TEST_DIARY D
                                 WHERE D.REQ_NUM = P.REQ_NUM
                                   AND D.ACCEPT_NUM = P.ACCEPT_NUM
                                 --  AND D.LAST_DECISION <> '101'
                                 AND D.LAST_DECISION = '102'
                               )
                )
            ELSE
                (
                 SELECT COUNT(1)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPTV X
                  WHERE  P.REQ_NUM = X.REQ_NUM
                   -- AND A.REQ_NUM = X.REQ_NUM
                    AND A.UPJANG = X.UPJANG
                    AND P.SPECM_CD IN (SELECT  SPECM_CD 
                                         FROM LRM_SPECM_INFO Z
                                        WHERE Z.REQ_NUM = A.REQ_NUM )
                    AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
              --      AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD  BETWEEN TO_CHAR(SYSDATE- (INTERVAL '1' YEAR),'YYYY')||'0701' AND TO_CHAR(SYSDATE,'YYYY')||'0630'
                    AND EXISTS (
                                SELECT 1
                                  FROM LTM_TEST_DIARY D
                                 WHERE D.REQ_NUM = P.REQ_NUM
                                   AND D.ACCEPT_NUM = P.ACCEPT_NUM
                                   --AND D.LAST_DECISION <> '101'
                                   AND D.LAST_DECISION = '102'
                               )
                )
            END  , 1) AS ALL_NOT_FIT_CNT  --누적부적합건수 (전자결재 상신시 부적합이력 표시 위해 추가)  20170414 맹수영
     , (
         SELECT COUNT(1)
           FROM LEM_INSPECT_RPT_ISSUE_LOG
          WHERE REQ_NUM = A.REQ_NUM
            AND PUBLISHDD IS NOT NULL
       ) AS INSPT_RPT_CNT /* 성적서 발급 건수 */
       -- 시작. 부적합상신/ 사후처리 내용 추가 20160613 처리자 : 맹수영 요청자 : 최준열 (SR201605_13252)
       -- 2018.02.05 김명섭 [CH201802_00006] USE_YN 조회 조건 추가
     , (
         SELECT CONTENTS
           FROM   SCC_COMMON_CODE A
          WHERE  A.GROUP_CODE = 'NOT_FIT_BIGO'
            AND  A.CODE = '101'
            AND  A.USE_YN = 'Y'
       ) NOT_FIT_BIGO_1 
     , (
         SELECT CONTENTS
           FROM   SCC_COMMON_CODE A
          WHERE  A.GROUP_CODE = 'NOT_FIT_BIGO'
            AND  A.CODE = '102'
            AND  A.USE_YN = 'Y'
       ) NOT_FIT_BIGO_2 
       -- 종료. 부적합상신/ 사후처리 내용 추가 20160613 처리자 : 맹수영 요청자 : 최준열
     --2018.06.15 김명섭 검사대상1속성Get
     , NVL((SELECT SET2
	          FROM LRM_SPECM_INFO T1, SCC_COMMON_CODE T2
	         WHERE T1.REQ_NUM = :reqNum
	           AND T1.INSPT_OBJ_1 = T2.CODE
	           AND T2.GROUP_CODE = 'INSPT_OBJ_1'
	           AND T2.SET2 = 'N'
	           AND ROWNUM = 1),'Y') AS PRINT_YN --결재상신 시 부적합구분및사후처리 표시 여부
     , A.APPROVAL_CLASS
  FROM LRM_TEST_REQ_ACCEPT A
     , (
         SELECT *
           FROM (
                 SELECT SCC_CODE_NM('INSPT_OBJ_1', INSPT_OBJ_1) AS INSPT_OBJ_1_NM
                      , SCC_CODE_NM('INSPT_OBJ_2', INSPT_OBJ_2) AS INSPT_OBJ_2_NM
                      , SCC_CODE_NM('INSPT_OBJ_3', INSPT_OBJ_3) AS INSPT_OBJ_3_NM
                      , SCC_CODE_NM('INSPT_OBJ_4', INSPT_OBJ_4) AS INSPT_OBJ_4_NM
                      , SPECM_NM
                      , SPECM_CD  --부적합 총누적 구하려고 추가 20170414 맹수영
                      , ACCEPTDD
                      , REQ_NUM
                      , INSPT_OBJ_3
                      , INSPT_OBJ_4
                      , ACCEPT_NUM
                      , ROW_NUMBER() OVER(PARTITION BY REQ_NUM ORDER BY ACCEPT_NUM) AS RN
                   FROM LRM_SPECM_INFO
                  WHERE REQ_NUM = :reqNum
                ) X
          WHERE X.RN = 1
       ) B
     , (
         SELECT LS.REQ_NUM
              , LISTAGG(LS.INSPT_OBJ_3_NM, ', ') WITHIN GROUP(ORDER BY LS.REQ_NUM) AS INSPT_OBJ_3	/*  oracle 11g에서만 동작하므로 아래 쿼리로 대체 */
              --, SUBSTR(XMLAGG(XMLElement("nm", ','||LS.INSPT_OBJ_3_NM) ORDER BY LS.REQ_NUM).EXTRACT('//text()').GetStringVal(), 2) AS INSPT_OBJ_3
              , MAX(LS.SPECM_TYPE_NM) AS SPECM_TYPE_NM
           FROM (
                 SELECT SL.REQ_NUM
                      , SL.MCALSS_CD
                      , (SELECT MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS WHERE MCALSS_CD = SL.MCALSS_CD AND USE_YN = 'Y') || '(' ||
                        NVL((
                          SELECT COUNT(1)
                            FROM LRM_SPECM_INFO
                           WHERE REQ_NUM = SL.REQ_NUM
                             AND MCALSS_CD = SL.MCALSS_CD
                           GROUP BY MCALSS_CD
                        ), 0) || ')'
                        AS INSPT_OBJ_3_NM   /* 검사유형1 */
                      ,((SELECT X.MGRP_NM FROM LCM_SPECM_TYPE_MGRP X WHERE X.SPECM_TYPE = SL.SPECM_TYPE AND X.MGRP_CD = SL.MGRP_CD) || ' / ' ||
                        (SELECT X.MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS X WHERE X.SPECM_TYPE = SL.SPECM_TYPE AND X.MCALSS_CD = SL.MCALSS_CD) || ' / ' ||
                        (SELECT X.SCLASS_NM FROM LCM_SPECM_TYPE_SCLASS X WHERE X.SPECM_TYPE = SL.SPECM_TYPE AND X.SCLASS_CD = SL.SCLASS_CD))
                       AS SPECM_TYPE_NM				/* 검체 유형명 ( 대분류명 / 중분류명 / 소분류명 ) */
                   FROM LRM_SPECM_INFO SL
                  WHERE SL.REQ_NUM = :reqNum
                  GROUP BY SL.REQ_NUM, SL.MCALSS_CD, SL.SPECM_TYPE, SL.MGRP_CD, SL.SCLASS_CD
               ) LS
           GROUP BY LS.REQ_NUM
       ) C
 WHERE A.REQ_NUM = :reqNum
   AND A.REQ_NUM = B.REQ_NUM
   AND A.REQ_NUM = C.REQ_NUM
        ]]></statement>

	<!-- 시험결과 상신 Detail를 조회한다. -->
	<statement name="selectReportDetail" type="select"><![CDATA[--2019.07.02 김명섭
--SELECT SPECM_CD
SELECT DISTINCT SPECM_CD
      ,SPECM_NM
      ,TEST_CNT
      ,LAST_DECISION_NM
      --,ARTICLE_CD
      --,ARTICLE_NM
      --결과가 적합이면 항목명이 표시 안되게 수정 20170417
      ,DECODE(LAST_DECISION_NM,'적합','',ARTICLE_CD) ARTICLE_CD
      ,DECODE(LAST_DECISION_NM,'적합','',ARTICLE_NM) ARTICLE_NM      
      ,BASIS_STAND
      ,RESULT
      ,INSPT_FLD_NM
      ,NOT_FIT_CLSFI_NM
      ,TESTDD
      ,NOT_FIT_CNT
      ,ROW_SPAN_CNT
      ,SPECM_NM||'/'||MFGWON||'/'||SPECM_CD||'/'||ARTICLE_NM||'('||NOT_FIT_CNT||'회)' NOT_FIT_HIS
      ,DECODE(TEST_CNT,1,ARTICLE_MAXNM,ARTICLE_MAXNM||' 외 '||TEST_INFO) AS ARTICLE_INFO
FROM (

SELECT A.SPECM_CD   /* 검체코드 */
     , A.SPECM_NM   /* 검체명 */
     , A.MFGWON   /*제조업체*/
     , (
        SELECT COUNT(1)
          FROM LTM_TEST_DIARY U
         WHERE U.REQ_NUM = A.REQ_NUM
           AND U.ACCEPT_NUM = A.ACCEPT_NUM
       ) AS TEST_CNT  /* 검사항목수 */
     , (
        SELECT COUNT(1) - 1
          FROM LTM_TEST_DIARY U
         WHERE U.REQ_NUM = A.REQ_NUM
           AND U.ACCEPT_NUM = A.ACCEPT_NUM
       ) AS TEST_INFO  /* 검사항목 */
     , (SELECT MAX(T2.ARTICLE_NM) FROM LTM_TEST_DIARY T1 , LCM_TEST_ARTICLE T2 WHERE T1.ARTICLE_CD = T2.ARTICLE_CD AND T1.REQ_NUM = A.REQ_NUM AND T1.ACCEPT_NUM = A.ACCEPT_NUM) ARTICLE_MAXNM	/* 검사항목대표명 */
     , CASE WHEN SCC_CODE_NM('LAST_DECISION', B.LAST_DECISION) IS NULL THEN
           '적합'
       ELSE
           SCC_CODE_NM('LAST_DECISION', B.LAST_DECISION)
       END AS LAST_DECISION_NM          /* 판정 */
    -- , B.ARTICLE_CD                     /* 항목코드 */
    -- , B.ARTICLE_NM                     /* 항목명 */
       ,  DECODE( ARTICLE_CD, NULL, CASE WHEN A.ACCEPTDD IS NOT NULL THEN
            CASE WHEN TO_CHAR(SYSDATE,'MM') BETWEEN '07' AND '12' THEN
            --부적합 횟수 계산 기준 변경 요청자:김민채  처리자:맹수영 20160704 (CH201607_00051)
            --CASE WHEN SUBSTR(A.ACCEPTDD,5,2) BETWEEN '07' AND '12' THEN
                (
                 SELECT MAX(D.ARTICLE_CD)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                       ,LTM_TEST_DIARY D
                  WHERE P.SPECM_CD = A.SPECM_CD
                    -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND D.REQ_NUM = P.REQ_NUM
                    AND D.ACCEPT_NUM = P.ACCEPT_NUM
                    AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    --AND P.ACCEPT_NUM = A.ACCEPT_NUM
              --      AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD BETWEEN TO_CHAR(SYSDATE,'YYYY')||'0101' AND TO_CHAR(SYSDATE,'YYYY')||'1231'
                    AND D.LAST_DECISION = '102'
                )
            ELSE
                (
                 SELECT MAX(D.ARTICLE_CD)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                       ,LTM_TEST_DIARY D
                  WHERE P.SPECM_CD = A.SPECM_CD
                    -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND D.REQ_NUM = P.REQ_NUM
                    AND D.ACCEPT_NUM = P.ACCEPT_NUM
                    AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD  BETWEEN TO_CHAR(SYSDATE- (INTERVAL '1' YEAR),'YYYY')||'0701' AND TO_CHAR(SYSDATE,'YYYY')||'0630'
                     AND D.LAST_DECISION = '102'
                )
            END
       ELSE
           ''
       END , ARTICLE_CD) AS ARTICLE_CD
   , DECODE( ARTICLE_CD, NULL,  CASE WHEN A.ACCEPTDD IS NOT NULL THEN
            CASE WHEN TO_CHAR(SYSDATE,'MM') BETWEEN '07' AND '12' THEN
            --부적합 횟수 계산 기준 변경 요청자:김민채  처리자:맹수영 20160704 (CH201607_00051)
            --CASE WHEN SUBSTR(A.ACCEPTDD,5,2) BETWEEN '07' AND '12' THEN
                (
                 SELECT (SELECT MAX(ARTICLE_NM) FROM LCM_TEST_ARTICLE Z WHERE Z.ARTICLE_CD =  D.ARTICLE_CD) ARTICLE_NM
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                       ,LTM_TEST_DIARY D
                  WHERE P.SPECM_CD = A.SPECM_CD
                    -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND D.REQ_NUM = P.REQ_NUM
                    AND D.ACCEPT_NUM = P.ACCEPT_NUM
                    AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    --AND P.ACCEPT_NUM = A.ACCEPT_NUM
                    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD BETWEEN TO_CHAR(SYSDATE,'YYYY')||'0101' AND TO_CHAR(SYSDATE,'YYYY')||'1231'
                    AND D.LAST_DECISION = '102'
                     AND ROWNUM = 1
                )
            ELSE
                (
                 SELECT  (SELECT MAX(ARTICLE_NM) FROM LCM_TEST_ARTICLE Z WHERE Z.ARTICLE_CD =  D.ARTICLE_CD) ARTICLE_NM
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                       ,LTM_TEST_DIARY D
                  WHERE P.SPECM_CD = A.SPECM_CD
                    -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND D.REQ_NUM = P.REQ_NUM
                    AND D.ACCEPT_NUM = P.ACCEPT_NUM
                    AND X.UPJANG_NM = :upjangNm
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD  BETWEEN TO_CHAR(SYSDATE- (INTERVAL '1' YEAR),'YYYY')||'0701' AND TO_CHAR(SYSDATE,'YYYY')||'0630'
                     AND D.LAST_DECISION = '102'
                     AND ROWNUM = 1
                )
            END
       ELSE
           ''
       END , ARTICLE_NM)  AS ARTICLE_NM   
     , B.BASIS_STAND                    /* 규격 */
     , B.RESULT                         /* 결과 */
     , B.INSPT_FLD_NM                   /* 검사분야명 */
     , B.NOT_FIT_CLSFI_NM               /* 부적합분류 */
     , B.TESTDD                         /* 판정일자 */
     , CASE WHEN A.ACCEPTDD IS NOT NULL THEN
            CASE WHEN TO_CHAR(SYSDATE,'MM') BETWEEN '07' AND '12' THEN
            --부적합 횟수 계산 기준 변경 요청자:김민채  처리자:맹수영 20160704 (CH201607_00051)
            --CASE WHEN SUBSTR(A.ACCEPTDD,5,2) BETWEEN '07' AND '12' THEN
                (
                 SELECT COUNT(1)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                  WHERE P.SPECM_CD = A.SPECM_CD
                    -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND X.UPJANG_NM = :upjangNm 
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    --AND P.ACCEPT_NUM = A.ACCEPT_NUM
                    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD BETWEEN TO_CHAR(SYSDATE,'YYYY')||'0101' AND TO_CHAR(SYSDATE,'YYYY')||'1231'
                    AND EXISTS (
                                SELECT 1
                                  FROM LTM_TEST_DIARY D
                                 WHERE D.REQ_NUM = P.REQ_NUM
                                   AND D.ACCEPT_NUM = P.ACCEPT_NUM
                                 --  AND D.LAST_DECISION <> '101'
                                 AND D.LAST_DECISION = '102'
                               )
                )
            ELSE
                (
                 SELECT COUNT(1)
                   FROM LRM_SPECM_INFO P
                       ,LRM_TEST_REQ_ACCEPT X
                  WHERE P.SPECM_CD = A.SPECM_CD
                     -- 부적합횟수 다른업장도 같이 합해져서 추가   20160315 맹수영
                    AND P.REQ_NUM = X.REQ_NUM
                    AND X.UPJANG_NM = :upjangNm 
                    -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
                    AND X.UPJANG = C.UPJANG
                    AND P.ACCEPTDD  BETWEEN TO_CHAR(SYSDATE- (INTERVAL '1' YEAR),'YYYY')||'0701' AND TO_CHAR(SYSDATE,'YYYY')||'0630'
                    AND EXISTS (
                                SELECT 1
                                  FROM LTM_TEST_DIARY D
                                 WHERE D.REQ_NUM = P.REQ_NUM
                                   AND D.ACCEPT_NUM = P.ACCEPT_NUM
                                   --AND D.LAST_DECISION <> '101'
                                   AND D.LAST_DECISION = '102'
                               )
                )
            END
       ELSE
           0
       END AS NOT_FIT_CNT
     , CASE WHEN (
                  SELECT COUNT(1)
                    FROM LTM_TEST_DIARY U
                   WHERE U.REQ_NUM = A.REQ_NUM
                     AND U.ACCEPT_NUM = A.ACCEPT_NUM
                    -- AND U.LAST_DECISION <> '101'
                    AND U.LAST_DECISION = '102'
                 ) <= 1 THEN 1
       ELSE
           (
            SELECT COUNT(1)
              FROM LTM_TEST_DIARY U
             WHERE U.REQ_NUM = A.REQ_NUM
               AND U.ACCEPT_NUM = A.ACCEPT_NUM
              -- AND U.LAST_DECISION <> '101'
              AND U.LAST_DECISION = '102'
           )
       END AS ROW_SPAN_CNT  /* HTML ROWSPAN을 위한 시료별 부적합항목수 */
  FROM LRM_SPECM_INFO A
     , (
     --2019.07.02 김명섭
     --   SELECT Y.REQ_NUM
     --        , Y.ACCEPT_NUM
     --        , Y.ARTICLE_CD
     --        , Z.ARTICLE_NM
     --        , Y.LAST_DECISION
     --        , X.BASIS_STAND
     --        , Y.RESULT
     --        , SCC_CODE_NM('INSPT_FLD', X.INSPT_FLD) AS INSPT_FLD_NM    /* 검사분야명 */
     --        , SCC_CODE_NM('NOT_FIT_CLSFI', Z.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM    /* 부적합분류명 */
     --        , Y.TESTDD
        SELECT Y.REQ_NUM AS REQ_NUM
             , Y.ACCEPT_NUM AS ACCEPT_NUM
             , DECODE(Y.LAST_DECISION,'102',Y.ARTICLE_CD,NULL) AS ARTICLE_CD
             , DECODE(Y.LAST_DECISION,'102',Z.ARTICLE_NM,NULL) AS ARTICLE_NM
             , Y.LAST_DECISION
             , DECODE(Y.LAST_DECISION,'102',X.BASIS_STAND,NULL) AS BASIS_STAND
             , DECODE(Y.LAST_DECISION,'102',Y.RESULT,NULL) AS RESULT
             , DECODE(Y.LAST_DECISION,'102',SCC_CODE_NM('INSPT_FLD', X.INSPT_FLD),NULL) AS INSPT_FLD_NM    /* 검사분야명 */
             --, DECODE(Y.LAST_DECISION,'102',SCC_CODE_NM('NOT_FIT_CLSFI', Z.NOT_FIT_CLSFI),NULL) AS NOT_FIT_CLSFI_NM    /* 부적합분류명 */
             , DECODE(X.LEGAL_BASIS,'Y','법적','내부') AS NOT_FIT_CLSFI_NM    /* 기준구분 */
             , DECODE(Y.LAST_DECISION,'102',Y.TESTDD,NULL) AS TESTDD
          FROM LRM_TEST_INFO X
             , LTM_TEST_DIARY Y
             , LCM_TEST_ARTICLE Z
         WHERE X.REQ_NUM = Y.REQ_NUM
           AND X.ACCEPT_NUM = Y.ACCEPT_NUM
           AND X.ARTICLE_CD = Y.ARTICLE_CD
           AND Y.ARTICLE_CD = Z.ARTICLE_CD
        --2019.07.02 김명섭
           AND Y.LAST_DECISION <> '101'
        --   AND Y.LAST_DECISION = '102'
       ) B
       -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
       , LRM_TEST_REQ_ACCEPT C
 WHERE A.REQ_NUM = :reqNum
   AND A.REQ_NUM = B.REQ_NUM(+)
   AND A.ACCEPT_NUM = B.ACCEPT_NUM(+)
   -- 업장별 부적합횟수 누적되도록 추가 20160721 맹수영
   AND A.REQ_NUM = C.REQ_NUM
 --   AND B.LAST_DECISION = '102'
 ORDER BY DECODE(B.ARTICLE_CD, NULL, 1, 0), A.SPECM_CD
 )
 ORDER BY DECODE(LAST_DECISION_NM, '부적합', 1, '적합', 2, 3), SPECM_CD]]></statement>

	<!-- 시험결과 상신 Detail를 조회한다. -->
	<statement name="selectReportDetail_back20151217" type="select">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectReportDetail
		*/
		<![CDATA[
/* 시험결과 상신 Detail를 조회한다. */
SELECT A.SPECM_NM
     , A.INSPT_OBJ_3
     , SCC_CODE_NM('INSPT_OBJ_3', A.INSPT_OBJ_3) AS INSPT_OBJ_3_NM
     , CASE WHEN (
                 SELECT COUNT(1)
                   FROM LTM_TEST_DIARY Z
                  WHERE Z.REQ_NUM = A.REQ_NUM
                    AND Z.ACCEPT_NUM = A.ACCEPT_NUM
                    AND Z.LAST_DECISION = '101'
                 ) > 0 THEN
                 '적합'
        END AS INSPT_OBJ_3_FIT
      , CASE WHEN (
                 SELECT COUNT(1)
                   FROM LTM_TEST_DIARY Z
                  WHERE Z.REQ_NUM = A.REQ_NUM
                    AND Z.ACCEPT_NUM = A.ACCEPT_NUM
                    AND Z.LAST_DECISION IN ('102')
                 ) > 0 THEN
                 '부적합('||
                 (
                  SELECT --SUBSTR(XMLAGG(XMLElement("nm", ','||TA.ARTICLE_NM) ORDER BY TA.ARTICLE_NM).EXTRACT('//text()').GetStringVal(), 2)
                         LISTAGG(TA.ARTICLE_NM||'[결과:'||SI.RESULT||']'||'[기준:'||TA.BASIS_STAND||']', ',') WITHIN GROUP(ORDER BY TA.ARTICLE_NM||'[결과:'||SI.RESULT||']'||'[기준:'||TA.BASIS_STAND||']')
                    FROM LTM_TEST_DIARY SI
                       , LCM_TEST_ARTICLE TA
                   WHERE SI.REQ_NUM = A.REQ_NUM
                     AND SI.ACCEPT_NUM = A.ACCEPT_NUM
                     AND SI.ARTICLE_CD = TA.ARTICLE_CD
                     AND SI.LAST_DECISION IN ('102')
                 )||')'
        END AS INSPT_OBJ_3_NOTFIT
      , CASE WHEN (
                 SELECT COUNT(1)
                   FROM LTM_TEST_DIARY Z
                  WHERE Z.REQ_NUM = A.REQ_NUM
                    AND Z.ACCEPT_NUM = A.ACCEPT_NUM
                    AND Z.LAST_DECISION IN ('102')
                 ) > 0 THEN
                 '부적합:' || C.INSPT_FLD_NM || '/' || C.NOT_FIT_CLSFI_NM
             WHEN (
                 SELECT COUNT(1)
                   FROM LTM_TEST_DIARY Z
                  WHERE Z.REQ_NUM = A.REQ_NUM
                    AND Z.ACCEPT_NUM = A.ACCEPT_NUM
                    AND Z.LAST_DECISION IN ('101')
                 ) > 0 THEN
                 '' /* 적합 */
             WHEN NOT EXISTS (
                              SELECT 1
                                FROM LTM_TEST_DIARY Z
                               WHERE Z.REQ_NUM = A.REQ_NUM
                                 AND Z.ACCEPT_NUM = A.ACCEPT_NUM
                             ) THEN
                 '' /* 일지 미작성 */
        END AS LAST_DECISION
  FROM LRM_SPECM_INFO A
     , (
        SELECT NF.REQ_NUM
             , NF.ACCEPT_NUM
             , NF.INSPT_FLD_NM
             , NF.NOT_FIT_CLSFI_NM
          FROM (
                 SELECT /*+ INDEX_FFS(Y) */
                        Y.REQ_NUM
                      , Y.ACCEPT_NUM
                      , P.INSPT_FLD
                      , SCC_CODE_NM('INSPT_FLD', P.INSPT_FLD) AS INSPT_FLD_NM
                      , Y.LAST_DECISION
                      , P.ARTICLE_NM
                      , P.NOT_FIT_CLSFI
                      , SCC_CODE_NM('NOT_FIT_CLSFI', P.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM
                      , ROW_NUMBER() OVER(PARTITION BY Y.REQ_NUM, Y.ACCEPT_NUM ORDER BY Y.REQ_NUM, Y.ACCEPT_NUM, P.NOT_FIT_CLSFI DESC) AS RN
                   FROM LTM_TEST_DIARY Y
                      , LCM_TEST_ARTICLE P
                  WHERE 1 = 1
                    AND Y.ARTICLE_CD = P.ARTICLE_CD
                    --AND Y.LAST_DECISION <> '101'
                    AND Y.LAST_DECISION = '102'
               ) NF
         WHERE NF.RN = 1
       ) C
 WHERE A.REQ_NUM = :reqNum
   AND A.REQ_NUM = C.REQ_NUM(+)
   AND A.ACCEPT_NUM = C.ACCEPT_NUM(+)
 ORDER BY A.ACCEPT_NUM
        ]]>
	</statement>

	<!-- 검체폐기 정보를 등록한다. -->
	<statement name="saveDisuseYn" type="update">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveDisuseYn */
		<![CDATA[
/* 검체폐기 정보를 등록한다. */
UPDATE LRM_SPECM_INFO SET
<#if disuseYn?exists && disuseYn = '1'>
    DISUSE_YN = 'Y', DISUSE_DATE = TO_CHAR(SYSDATE, 'YYYYMMDD')
<#else>
    DISUSE_YN = NULL, DISUSE_DATE = NULL
</#if>
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
        ]]>
	</statement>

	<!-- 성적서 발급여부를 변경 한다. -->
	<statement name="saveInspectRptIssueYn" type="update">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveInspectRptIssueYn
		*/
		<![CDATA[
/* 성적서 발급여부를 변경한다. */
UPDATE LRM_TEST_REQ_ACCEPT SET
<#if inspectRptIssue?exists && inspectRptIssue = '1'>
    INSPECT_RPT_ISSUE = 'Y'
<#else>
    INSPECT_RPT_ISSUE = NULL
</#if>
WHERE  REQ_NUM = :reqNum
        ]]>
	</statement>

	<!-- 검체 폐기대상 목록을 조회한다. -->
	<statement name="selectSpecmDisuseList" type="select">
		/*+
		com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectSpecmDisuseList
		*/
		<![CDATA[
/* 검체 폐기대상 목록 조회 */
SELECT '0' AS CHK,
       B.REQ_DATE,
       A.REQ_NUM,
       B.ACCEPTNM,
       A.ACCEPT_NUM,
       A.ACCEPTDD,
       A.SPECM_CD,                      /* 검체 코드 */
       A.SPECM_CLASS,                   /* 검체 분류 */
       A.SPECM_NM,                      /* 검체명 */
       A.SPECM_TYPE,                    /* 검체유형(공전유형) */
       SCC_CODE_NM('SPECM_TYPE', A.SPECM_TYPE) AS SPECM_TYPE_NM,    /* 검체유형(공전유형)명 */
       A.MGRP_CD,                       /* 검체유형 대분류 */
       A.MCALSS_CD,                     /* 검체유형 중분류 */
       A.SCLASS_CD,                     /* 검체유형 소분류 */
       (SELECT X.MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.MCALSS_CD = A.MCALSS_CD AND X.USE_YN = 'Y') MCLASS_NM,
       ((SELECT X.MGRP_NM FROM LCM_SPECM_TYPE_MGRP X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.MGRP_CD = A.MGRP_CD AND X.USE_YN = 'Y') || ' / ' ||
        (SELECT X.MCALSS_NM FROM LCM_SPECM_TYPE_MCALSS X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.MCALSS_CD = A.MCALSS_CD AND X.USE_YN = 'Y') || ' / ' ||
        (SELECT X.SCLASS_NM FROM LCM_SPECM_TYPE_SCLASS X WHERE X.SPECM_TYPE = A.SPECM_TYPE AND X.SCLASS_CD = A.SCLASS_CD AND X.USE_YN = 'Y'))
       AS SPECM_TYPE_DESC,              /* 검체 유형명 ( 대분류명 / 중분류명 / 소분류명 ) */
       A.INSPT_MTOD,                    /* 검사방법 */
       SCC_CODE_NM('INSPT_MTOD', A.INSPT_MTOD) AS INSPT_MTOD_NM,
       A.INSPT_CLASS,                   /* 검사구분 */
       SCC_CODE_NM('INSPT_CLASS', A.INSPT_CLASS) AS INSPT_CLASS_NM,
       A.INSPT_PURP_1,                  /* 검사목적1 */
       SCC_CODE_NM('INSPT_PURP_1', A.INSPT_PURP_1) AS INSPT_PURP_1_NM,
       A.INSPT_PURP_2,                  /* 검사목적2 */
       SCC_CODE_NM('INSPT_PURP_2', A.INSPT_PURP_2) AS INSPT_PURP_2_NM,
       A.INSPT_PURP_3,                  /* 검사목적3 */
       SCC_CODE_NM('INSPT_PURP_3', A.INSPT_PURP_3) AS INSPT_PURP_3_NM,
       A.LONGSTORAGE_YN,                /* 장기보존여부 */
       SCC_CODE_NM('LONGSTORAGE_YN', A.LONGSTORAGE_YN) AS LONGSTORAGE_YN_NM,
       A.INSPT_OBJ_1,                   /* 검사대상1 */
       SCC_CODE_NM('INSPT_OBJ_1', A.INSPT_OBJ_1) AS INSPT_OBJ_1_NM,
       A.INSPT_OBJ_2,                   /* 검사대상2 */
       SCC_CODE_NM('INSPT_OBJ_2', A.INSPT_OBJ_2) AS INSPT_OBJ_2_NM,
       A.INSPT_OBJ_3,                   /* 검사대상3 */
       SCC_CODE_NM('INSPT_OBJ_3', A.INSPT_OBJ_3) AS INSPT_OBJ_3_NM,
       A.INSPT_OBJ_4,                   /* 검사대상4 */
       SCC_CODE_NM('INSPT_OBJ_4', A.INSPT_OBJ_4) AS INSPT_OBJ_4_NM,
       A.ORIGIN                        /* 원산지 */
     , CASE WHEN (SELECT COUNT(1) FROM LRM_TEST_INFO WHERE REQ_NUM = A.REQ_NUM) =
                 (SELECT COUNT(1) FROM LTM_TEST_DIARY WHERE REQ_NUM = A.REQ_NUM AND LAST_DECISION IS NOT NULL)
            THEN
              (SELECT TO_CHAR(MAX(UDATE), 'YYYYMMDD')
                 FROM LTM_TEST_DIARY
                WHERE REQ_NUM = A.REQ_NUM)
            ELSE
              ''
       END AS COMPLETE_DD   /* 시험완료일자 */
     , B.UPJANG_NM
     , SCC_CODE_NM('ACCEPT_CLASS', B.ACCEPT_CLASS) AS ACCEPT_CLASS
     , U.PROC_CLASS AS PROGRESS_STATUS  /* 진행상태 */
     , SCC_CODE_NM('PROGRESS_STATUS', U.PROC_CLASS) AS PROGRESS_STATUS_NM   /* 진행상황 */
     , CASE WHEN U.PROC_CLASS >= '200' THEN /* 시험완료 승인 */
          'Y'
       ELSE
          'N'
       END AS COMPLETE_YN   /* 시험완료승인 */
     , (
         SELECT COUNT(1)
           FROM LEM_INSPECT_RPT_ISSUE_LOG
          WHERE REQ_NUM = A.REQ_NUM
            AND PUBLISHDD IS NOT NULL
       ) AS PUBLISH_CNT /* 발급횟수 */
     , DECODE(B.INSPECT_RPT_ISSUE, NULL, 'N', B.INSPECT_RPT_ISSUE) AS INSPECT_RPT_ISSUE    /* 성적서 발급 여부 */
     , H.INSPT_FLD_NM || '/' || H.NOT_FIT_CLSFI_NM AS NOT_FIT_CLSFI_NM    /* 검사분야 / 부적합분류 */
     , A.DISUSE_YN      /* 폐기 여부 */
     , A.DISUSE_DATE    /* 폐기 일자 */
FROM   LRM_SPECM_INFO A
     , LRM_TEST_REQ_ACCEPT B
     , (
        SELECT PD.REQ_NUM
             , PD.PROC_USER
             , PD.PROCDD
             , PD.PROC_REASON
             , PD.PROC_CLASS
             , PD.SEQ
          FROM (
                SELECT Y.REQ_NUM
                     , Y.PROC_USER
                     , Y.PROCDD
                     , Y.PROC_REASON
                     , Y.PROC_CLASS
                     , Y.SEQ
                     , ROW_NUMBER() OVER (PARTITION BY Y.REQ_NUM ORDER BY Y.REQ_NUM, Y.SEQ DESC) AS RN
                  FROM LRM_PROC_DESC Y
               ) PD
         WHERE RN = 1
       ) U
     , (
        SELECT NF.REQ_NUM
             , NF.ACCEPT_NUM
             , NF.INSPT_FLD_NM
             , NF.NOT_FIT_CLSFI_NM
          FROM (
                 SELECT /*+ INDEX_FFS(Y) */
                        Y.REQ_NUM
                      , Y.ACCEPT_NUM
                      , P.INSPT_FLD
                      , SCC_CODE_NM('INSPT_FLD', P.INSPT_FLD) AS INSPT_FLD_NM
                      , Y.LAST_DECISION
                      , P.ARTICLE_NM
                      , P.NOT_FIT_CLSFI
                      , SCC_CODE_NM('NOT_FIT_CLSFI', P.NOT_FIT_CLSFI) AS NOT_FIT_CLSFI_NM
                      , ROW_NUMBER() OVER(PARTITION BY Y.REQ_NUM, Y.ACCEPT_NUM ORDER BY Y.REQ_NUM, Y.ACCEPT_NUM, P.NOT_FIT_CLSFI DESC) AS RN
                   FROM LTM_TEST_DIARY Y
                      , LCM_TEST_ARTICLE P
                  WHERE 1 = 1
                    AND Y.ARTICLE_CD = P.ARTICLE_CD
                   -- AND Y.LAST_DECISION <> '101'
                   AND Y.LAST_DECISION = '102'
               ) NF
         WHERE NF.RN = 1
       ) H
WHERE  1 = 1
  AND  A.REQ_NUM = B.REQ_NUM
  AND  A.REQ_NUM = U.REQ_NUM(+)
  AND  A.REQ_NUM = H.REQ_NUM(+)
  AND  A.ACCEPT_NUM = H.ACCEPT_NUM(+)
<#if toDay?has_content> AND B.REQ_DATE BETWEEN :fromDay AND :toDay </#if>
<#if disuseYn?has_content>
    <#if disuseYn = 'Y'> AND A.DISUSE_YN = 'Y'
    <#else> AND (A.DISUSE_YN = 'N' OR A.DISUSE_YN IS NULL)
    </#if>
</#if>
<#if specmNm?has_content> AND A.SPECM_NM LIKE '%' || :specmNm || '%' </#if>
ORDER  BY A.REQ_NUM, A.ACCEPT_NUM
        ]]>
	</statement>

	<!-- 검체폐기 정보를 일괄 등록한다. -->
	<statement name="saveDisuseAllYn" type="update">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.saveDisuseAllYn */
		<![CDATA[
/* 검체폐기 정보를 일괄 등록한다. */
UPDATE LRM_SPECM_INFO SET
    DISUSE_YN = DECODE(DISUSE_YN, NULL, 'Y', NULL)
  , DISUSE_DATE = DECODE(DISUSE_DATE, NULL, TO_CHAR(SYSDATE, 'YYYYMMDD'), NULL)
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
        ]]>
	</statement>

	<!-- 서버 사진을 조회한다. -->
	<statement name="selectImgList" type="select">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectImgList */
		<![CDATA[
SELECT 0                            AS CHK
     , RGST_SEQ                     AS RGST_SEQ
     , UPJANG                       AS UPJANG
     , RGST_DATE                    AS RGST_DATE
     , GUBUN                        AS GUBUN
     , FILE_NM                      AS FILE_NM
     , REL_PATH                     AS REL_PATH
     , REL_PATH || '/' || FILE_NM   AS PRE_VIEW
     , FILE_SIZE                    AS FILE_SIZE
     , BIGO                         AS BIGO
  FROM SCZ_PHOTO_IMGSEND
 WHERE 1 = 1
   AND RGST_DATE = :rgstDate
   AND GUBUN     = :gubun
 ORDER BY CDATE DESC
        ]]>
	</statement>

	<statement name="insertSendItem"><![CDATA[            MERGE INTO LRM_MATERIAL_INFO X
            USING DUAL
            ON (
                X.REQ_NUM = :reqNum
                AND X.ACCEPT_NUM = :acceptNum
            )
            WHEN MATCHED THEN
                UPDATE SET
                     SPECM_CD  = :specmCd
                    ,SEND_INFO = '구매 수기 전송'
                    ,IF_PARAM  = ''
                    ,SEND_RESULT = 'T' || ''
                    ,MATERIAL_SEND_RESULT = 'S'
                    ,MATERIAL_UPJANG_SEND_RESULT = ''
                    ,UUSER     = :loginSabun
                    ,UDATE     = SYSDATE
            WHEN NOT MATCHED THEN
                INSERT (
                     REQ_NUM
                    ,ACCEPT_NUM
                    ,SPECM_CD
                    ,SEND_INFO
                    ,IF_PARAM
                    ,SEND_RESULT
                    ,MATERIAL_SEND_RESULT
                    ,MATERIAL_UPJANG_SEND_RESULT
                    ,CUSER
                    ,CDATE
                    ,UUSER
                    ,UDATE
                ) VALUES (
                     :reqNum
                    ,:acceptNum
                    ,:specmCd
                    , '구매 수기 전송'
                    ,''
                    ,'T' || ''
                    ,'S'
                    ,''
                    ,:loginSabun
                    ,SYSDATE
                    ,:loginSabun
                    ,SYSDATE
                )]]></statement>

	<!-- 결재상신팝업 저장내역 조회 -->
	<statement name="selectGwDraftTemp" type="select">
		/*+ com.hwfs.ls.ltm.dao.TestResultInqueryDAO.selectGwDraftTemp
		*/
		<![CDATA[
		SELECT REQ_NUM
		     , DRAFT_TITLE
		     , INSPT_PURP
		     , INSPT_MTOD
		     , FILE_NM
		     , BIGO
		     , AFTERPROC
		  FROM LRM_TEST_GW_TEMP
		 WHERE REQ_NUM = :reqNum
        ]]>
	</statement>


	<!-- 결재상신 팝업 임시저장-->
	<statement name="saveGwDraftTemp" type="insert">
		/*+ com.hwfs.ls.lrm.dao.TestResultInqueryDAO.saveGwDraftTemp */
		<![CDATA[
            MERGE INTO LRM_TEST_GW_TEMP T1
             USING (SELECT :reqNum 	    AS REQ_NUM
                         , :draftTitle 	AS DRAFT_TITLE
                         , :insptPurp 	AS INSPT_PURP
                         , :insptMtod 	AS INSPT_MTOD
                         , <#if fileNm?exists>:fileNm<#else>null</#if> 	AS FILE_NM
                         , <#if bigo?exists>:bigo<#else>null</#if> 	    AS BIGO
                         , <#if afterproc?exists>:afterproc<#else>null</#if> 	    AS AFTERPROC
                         , :loginSabun 	AS SABUN
                      FROM DUAL
                   ) T2
                ON (T1.REQ_NUM = T2.REQ_NUM)
              WHEN MATCHED THEN
                   UPDATE
                      SET DRAFT_TITLE   = T2.DRAFT_TITLE
                        , INSPT_PURP    = T2.INSPT_PURP
                        , INSPT_MTOD    = T2.INSPT_MTOD
                        , FILE_NM       = T2.FILE_NM
                        , BIGO          = T2.BIGO
                        , AFTERPROC          = T2.AFTERPROC
                        , UUSER         = T2.SABUN
                        , UDATE         = SYSDATE
              WHEN NOT MATCHED THEN
                   INSERT
                   (
                          REQ_NUM
                        , DRAFT_TITLE
                        , INSPT_PURP
                        , INSPT_MTOD
                        , FILE_NM
                        , BIGO
                        , AFTERPROC
                        , CUSER
                        , CDATE
                        , UUSER
                        , UDATE
                   )
                   VALUES
                   (
                          T2.REQ_NUM
                        , T2.DRAFT_TITLE
                        , T2.INSPT_PURP
                        , T2.INSPT_MTOD
                        , T2.FILE_NM
                        , T2.BIGO
                        , T2.AFTERPROC
                        , T2.SABUN
                        , SYSDATE
                        , T2.SABUN
                        , SYSDATE
                   )
        ]]>
	</statement>

	<statement name="updateBasisStand"><![CDATA[/* 시험항목정보 기준규격 수정 */
UPDATE LRM_TEST_INFO SET
<#if basisStand?exists> BASIS_STAND = :basisStand, </#if>
       UUSER = :loginSabun,
       UDATE = SYSDATE
WHERE  REQ_NUM = :reqNum
AND    ACCEPT_NUM = :acceptNum
AND    ARTICLE_CD = :articleCd]]></statement>
</hqml>
